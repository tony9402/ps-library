{
    "2D Segment Tree": {
        "prefix": [
            "2dseg",
            "2seg"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/11658\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 12:20 AM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T>\n\"",
            "\"struct Segment2D{\n\"",
            "\"    vector<vector<T>> tree;\n\"",
            "\"    int sizY, sizX;\n\"",
            "\"\n\"",
            "\"    Segment2D() { }\n\"",
            "\"    Segment2D(int y, int x){ setSize(y, x); }\n\"",
            "\"\n\"",
            "\"    void setSize(int y, int x){\n\"",
            "\"        sizY = sizX = 1;\n\"",
            "\"        while(sizY <= y)sizY <<= 1;\n\"",
            "\"        while(sizX <= x)sizX <<= 1;\n\"",
            "\"        tree.resize(2 * sizY);\n\"",
            "\"        for(int i=0; i < sizY * 2; i++) tree[i].resize(2 * sizX);\n\"",
            "\"    }\n\"",
            "\"    void putItem(int y, int x, T data){ tree[sizY + y][sizX + x]  = data; }\n\"",
            "\"    void addItem(int y, int x, T data){ tree[sizY + y][sizX + x] += data; }\n\"",
            "\"    void build(){\n\"",
            "\"        for(int i=sizY;i<sizY*2;i++)\n\"",
            "\"            for(int j=sizX-1;j;j--)\n\"",
            "\"                tree[i][j] = merge(tree[i][j<<1], tree[i][j<<1|1]);\n\"",
            "\"\n\"",
            "\"        for(int i=sizY-1;i;i--)\n\"",
            "\"            for(int j=0;j<2*sizX;j++)\n\"",
            "\"                tree[i][j]=merge(tree[i<<1][j], tree[i<<1|1][j]);\n\"",
            "\"    }\n\"",
            "\"    void update(int y, int x, T data, bool add=false){\n\"",
            "\"        if(add) addItem(y, x, data);\n\"",
            "\"        else    putItem(y, x, data);\n\"",
            "\"        x += sizX; y += sizY;\n\"",
            "\"        for(int i = x >> 1; i; i >>= 1) tree[y][i] = merge(tree[y][i << 1], tree[y][i << 1 | 1]);\n\"",
            "\"\n\"",
            "\"        for(int i = y >> 1; i; i >>= 1)\n\"",
            "\"            for(int j = x; j; j >>= 1)\n\"",
            "\"                tree[i][j] = merge(tree[i<<1][j], tree[i<<1|1][j]);\n\"",
            "\"    }\n\"",
            "\"    T query1D(int y, int l, int r){\n\"",
            "\"        T ret = 0;\n\"",
            "\"        for(l += sizX, r += sizX + 1; l < r; l >>= 1, r >>= 1){\n\"",
            "\"            if(l & 1) ret += tree[y][l++];\n\"",
            "\"            if(r & 1) ret += tree[y][--r];\n\"",
            "\"        }\n\"",
            "\"        return ret;\n\"",
            "\"    }\n\"",
            "\"    T query(int y1, int x1, int y2, int x2){\n\"",
            "\"        T ret = 0;\n\"",
            "\"        for(y1 += sizY, y2 += sizY + 1; y1 < y2; y1 >>= 1, y2 >>= 1){\n\"",
            "\"            if(y1&1) ret += query1D(y1++, x1, x2);\n\"",
            "\"            if(y2&1) ret += query1D(--y2, x1, x2);\n\"",
            "\"        }\n\"",
            "\"        return ret;\n\"",
            "\"    }\n\"",
            "\"    T merge(T, T);\n\"",
            "\"};\""
        ],
        "description": "2D Segment Tree"
    },
    "Aho-Corasick": {
        "prefix": [
            "aho",
            "corasick",
            "aho-corasick"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/9250\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.02 03:00 AM (KST)\n\"",
            "\" */\n\"",
            "\"struct AhoCorasick {\n\"",
            "\"    struct Trie {\n\"",
            "\"        Trie *nxt[26];\n\"",
            "\"        Trie *fail;\n\"",
            "\"        bool output;\n\"",
            "\"\n\"",
            "\"        Trie() {\n\"",
            "\"            for(int i=0;i<26;++i) nxt[i]=nullptr;\n\"",
            "\"            fail=nullptr;\n\"",
            "\"            output=false;\n\"",
            "\"        }\n\"",
            "\"        ~Trie() {\n\"",
            "\"            for(int i=0;i<26;++i) if(nxt[i]) delete nxt[i];\n\"",
            "\"        }\n\"",
            "\"    } *root;\n\"",
            "\"    AhoCorasick() { root = new Trie(); }\n\"",
            "\"    void insert(const string &S) {\n\"",
            "\"        Trie *cur = root;\n\"",
            "\"        int N = (int)S.size();\n\"",
            "\"        for(int i = 0; i < N; ++i) {\n\"",
            "\"            int nxt = S[i] - 'a';\n\"",
            "\"            if(cur->nxt[nxt] == nullptr) cur->nxt[nxt] = new Trie();\n\"",
            "\"            cur = cur->nxt[nxt];\n\"",
            "\"        }\n\"",
            "\"        cur->output=true;\n\"",
            "\"    }\n\"",
            "\"    void build() {\n\"",
            "\"        queue<Trie*> Q;\n\"",
            "\"        root->fail = root;\n\"",
            "\"        Q.push(root);\n\"",
            "\"        while(!Q.empty()) {\n\"",
            "\"            Trie* cur = Q.front(); Q.pop();\n\"",
            "\"\n\"",
            "\"            for(int i = 0; i < 26; ++i) {\n\"",
            "\"                Trie *next = cur->nxt[i];\n\"",
            "\"                if(next == nullptr) continue;\n\"",
            "\"                if(cur == root) next->fail = root;\n\"",
            "\"                else {\n\"",
            "\"                    Trie *dst = cur->fail;\n\"",
            "\"                    while(dst != root && dst->nxt[i] == nullptr) dst = dst->fail;\n\"",
            "\"                    if(dst->nxt[i]) dst = dst->nxt[i];\n\"",
            "\"                    next->fail = dst;\n\"",
            "\"                }\n\"",
            "\"                if(next->fail->output) next->output = true;\n\"",
            "\"                Q.push(next);\n\"",
            "\"            }\n\"",
            "\"        }\n\"",
            "\"    }\n\"",
            "\"    bool find(const string &S) {\n\"",
            "\"        Trie *cur = root;\n\"",
            "\"        int N = (int)S.size();\n\"",
            "\"        for(int i = 0; i < N; ++i) {\n\"",
            "\"            int nxt = S[i] - 'a';\n\"",
            "\"            while(cur != root && cur->nxt[nxt] == nullptr) cur = cur->fail;\n\"",
            "\"            if(cur->nxt[nxt]) cur = cur->nxt[nxt];\n\"",
            "\"            if(cur->output) return true;\n\"",
            "\"        }\n\"",
            "\"        return false;\n\"",
            "\"    }\n\"",
            "\"};\n\""
        ],
        "description": "Aho-Corasick"
    },
    "Dijkstra": {
        "prefix": [
            "dijkstra"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/1753\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.02 09:07 AM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T> struct Dijkstra {\n\"",
            "\"    const T INF = numeric_limits<T>::max();\n\"",
            "\"    Graph<pair<int, T>> G;\n\"",
            "\"    int N;\n\"",
            "\"    Dijkstra(Graph<pair<int, T>> G):G(G) { N = (int)G.size(); }\n\"",
            "\"    vector<T> dijkstra(int S) {\n\"",
            "\"        vector<T> dist(N, INF);\n\"",
            "\"        priority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> pq;\n\"",
            "\"        pq.emplace(dist[S] = 0, S);\n\"",
            "\"        while(!pq.empty()) {\n\"",
            "\"            auto [d, cur] = pq.top(); pq.pop();\n\"",
            "\"            if(dist[cur] != d) continue;\n\"",
            "\"            for(auto [nxt, w] : G[cur]) {\n\"",
            "\"                if(dist[nxt] > dist[cur] + w) {\n\"",
            "\"                    dist[nxt] = dist[cur] + w;\n\"",
            "\"                    pq.emplace(dist[nxt], nxt);\n\"",
            "\"                }\n\"",
            "\"            }\n\"",
            "\"        }\n\"",
            "\"        return dist;\n\"",
            "\"    }\n\"",
            "\"};\n\""
        ],
        "description": "Dijkstra"
    },
    "Dinic": {
        "prefix": [
            "flow",
            "dinic"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/11377\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 12:52 AM (KST)\n\"",
            "\" */\n\"",
            "\"struct Dinic {\n\"",
            "\"    struct Edge {\n\"",
            "\"        int to, c, f;\n\"",
            "\"        Edge* r;\n\"",
            "\"        Edge() { Edge(-1, 0); }\n\"",
            "\"        Edge(int _to, int _c) :to(_to), c(_c), f(0), r(nullptr) { }\n\"",
            "\"        int spare() { return c - f; }\n\"",
            "\"        void setRev(Edge* rev) { r = rev; }\n\"",
            "\"    };\n\"",
            "\"\n\"",
            "\"    vector<vector<Edge*>> graph;\n\"",
            "\"    vector<int> level, work;\n\"",
            "\"    int src, snk, asrc, asnk;\n\"",
            "\"\n\"",
            "\"    Dinic() { }\n\"",
            "\"    void init(int N) {\n\"",
            "\"        src = N + 1; snk = src + 1; asrc = snk + 1; asnk = asrc + 1;\n\"",
            "\"        N += 5;\n\"",
            "\"        graph.resize(N); level.resize(N); work.resize(N);\n\"",
            "\"    }\n\"",
            "\"    void clear() { graph.clear(); level.clear(); work.clear(); }\n\"",
            "\"\n\"",
            "\"    bool bfs(int s, int e) {\n\"",
            "\"        fill(level.begin(), level.end(), -1);\n\"",
            "\"        level[s] = 0;\n\"",
            "\"\n\"",
            "\"        queue<int> q;\n\"",
            "\"        q.push(s);\n\"",
            "\"\n\"",
            "\"        while (!q.empty()) {\n\"",
            "\"            int t = q.front(); q.pop();\n\"",
            "\"\n\"",
            "\"            for (auto i : graph[t]) {\n\"",
            "\"                if (i->spare() > 0 && level[i->to] == -1) {\n\"",
            "\"                    level[i->to] = level[t] + 1;\n\"",
            "\"                    q.push(i->to);\n\"",
            "\"                }\n\"",
            "\"            }\n\"",
            "\"        }\n\"",
            "\"        return level[e] != -1;\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    int dfs(int s, int e, int f) {\n\"",
            "\"        if (s == e)return f;\n\"",
            "\"\n\"",
            "\"        for (int& i = work[s]; i < (int)graph[s].size(); i++) {\n\"",
            "\"            Edge* now = graph[s][i];\n\"",
            "\"            if (level[now->to] == level[s] + 1 && now->spare() > 0) {\n\"",
            "\"                int ret = dfs(now->to, e, min(f, now->spare()));\n\"",
            "\"                if (ret > 0) {\n\"",
            "\"                    now->f += ret;\n\"",
            "\"                    now->r->f -= ret;\n\"",
            "\"                    return ret;\n\"",
            "\"                }\n\"",
            "\"            }\n\"",
            "\"        }\n\"",
            "\"        return 0;\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    int Flow(int s, int e) {\n\"",
            "\"        int flow = 0;\n\"",
            "\"        while (bfs(s, e)) {\n\"",
            "\"            fill(work.begin(), work.end(), 0);\n\"",
            "\"            while (1) {\n\"",
            "\"                int ret = dfs(s, e, 0x3f3f3f3f);\n\"",
            "\"                if (ret == 0)break;\n\"",
            "\"                flow += ret;\n\"",
            "\"            }\n\"",
            "\"        }\n\"",
            "\"        return flow;\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    Edge* addEdge(int u, int v, int c, bool directed = true, bool Unique = false) {\n\"",
            "\"        if (Unique) {\n\"",
            "\"            for (auto i : graph[u]) {\n\"",
            "\"                if (i->to == v) {\n\"",
            "\"                    i->c += c;\n\"",
            "\"                    if (!directed)return i;\n\"",
            "\"                    break;\n\"",
            "\"                }\n\"",
            "\"            }\n\"",
            "\"            if (!directed) {\n\"",
            "\"                for (auto i : graph[v]) {\n\"",
            "\"                    if (i->to == u) {\n\"",
            "\"                        i->c += c;\n\"",
            "\"                        return i;\n\"",
            "\"                    }\n\"",
            "\"                }\n\"",
            "\"            }\n\"",
            "\"        }\n\"",
            "\"\n\"",
            "\"        Edge* uv = new Edge(v, c);\n\"",
            "\"        Edge* vu = new Edge(u, directed ? 0 : c);\n\"",
            "\"        uv->setRev(vu); vu->setRev(uv);\n\"",
            "\"        graph[u].push_back(uv);\n\"",
            "\"        graph[v].push_back(vu);\n\"",
            "\"\n\"",
            "\"        return uv;\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    Edge* addLREdge(int u, int v, int lower, int upper) {\n\"",
            "\"        if (lower) {\n\"",
            "\"            addEdge(asrc, v, lower);\n\"",
            "\"            addEdge(u, asnk, lower);\n\"",
            "\"        }\n\"",
            "\"\n\"",
            "\"        return addEdge(u, v, upper - lower);\n\"",
            "\"    }\n\"",
            "\"};\""
        ],
        "description": "Dinic"
    },
    "Dynamic Segment Tree with Lazy Propagation": {
        "prefix": [
            "dseglazy",
            "dynamic_segment_lazy"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/20212\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 03:04 PM (KST)\n\"",
            "\" */\n\"",
            "\"const int MAXL = 1000000000;\n\"",
            "\"template<typename T>\n\"",
            "\"struct DynamicSegmentLazy{\n\"",
            "\"    struct Node{\n\"",
            "\"        int l, r; // range\n\"",
            "\"        T data, lazy;\n\"",
            "\"        Node *left, *right;\n\"",
            "\"        Node():l(1),r(MAXL),data(0),lazy(0),left(0),right(0) { }\n\"",
            "\"        void extend(T lzy=0){\n\"",
            "\"            if(l == r)return;\n\"",
            "\"            if(left == 0){ //if leaf node\n\"",
            "\"                left  = new Node();\n\"",
            "\"                right =  new Node();\n\"",
            "\"                int m = (l + r) / 2;\n\"",
            "\"                left->l  = l;\n\"",
            "\"                left->r  = m;\n\"",
            "\"                right->l = m + 1;\n\"",
            "\"                right->r = r; \n\"",
            "\"            }\n\"",
            "\"            left->lazy += lzy;\n\"",
            "\"            right->lazy += lzy;\n\"",
            "\"            return;\n\"",
            "\"        }\n\"",
            "\"    };\n\"",
            "\"    Node *tree;\n\"",
            "\"\n\"",
            "\"    DynamicSegmentLazy() { tree = new Node(); }\n\"",
            "\"    void pushdown(Node *cur){\n\"",
            "\"        if(cur->lazy){\n\"",
            "\"            cur->data += (cur->r - cur->l + 1) * cur->lazy;\n\"",
            "\"            cur->extend(cur->lazy);\n\"",
            "\"            cur->lazy = 0;\n\"",
            "\"        }\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    void update(Node *cur, int l, int r, T data){\n\"",
            "\"        pushdown(cur);\n\"",
            "\"        if(cur->l > cur->r || cur->l > r || l > cur->r)return;\n\"",
            "\"        if(l <= cur->l && cur->r <= r){\n\"",
            "\"            cur->data += (cur->r - cur->l + 1) * data;\n\"",
            "\"            if(cur->l != cur->r)cur->extend(data);\n\"",
            "\"            return;\n\"",
            "\"        }\n\"",
            "\"        cur->extend();\n\"",
            "\"        update(cur->left, l, r, data);\n\"",
            "\"        update(cur->right, l, r, data);\n\"",
            "\"        cur->data = mergeNode(cur->left->data, cur->right->data);\n\"",
            "\"    }\n\"",
            "\"    void update(int l, int r, T data){ update(tree, l, r, data); }\n\"",
            "\"\n\"",
            "\"    T query(Node *cur, int l, int r){\n\"",
            "\"        if(cur->l > cur->r || cur->l > r || l > cur->r)return T(0);\n\"",
            "\"        pushdown(cur);\n\"",
            "\"        if(l <= cur->l && cur->r <= r)return cur->data;\n\"",
            "\"        cur->extend();\n\"",
            "\"        return mergeNode(query(cur->left, l, r), query(cur->right, l, r));\n\"",
            "\"    }\n\"",
            "\"    T query(int l, int r){ return query(tree, l, r); }\n\"",
            "\"    T merge(T, T);\n\"",
            "\"};\""
        ],
        "description": "Dynamic Segment Tree with Lazy Propagation"
    },
    "Dynamic Segment Tree": {
        "prefix": [
            "dseg",
            "dynamic_segment"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/2042\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 03:00 PM (KST)\n\"",
            "\" */\n\"",
            "\"const int MAXL = 1000000000;\n\"",
            "\"template<typename T>\n\"",
            "\"struct DynamicSegment{\n\"",
            "\"    struct Node{\n\"",
            "\"        int l, r; // range\n\"",
            "\"        T data;\n\"",
            "\"        Node *left, *right;\n\"",
            "\"        Node():l(1),r(MAXL),data(0),left(nullptr),right(nullptr) { }\n\"",
            "\"        void extend(){\n\"",
            "\"            if(l == r)return;\n\"",
            "\"            if(left == nullptr){ //if leaf node\n\"",
            "\"                left  = new Node();\n\"",
            "\"                right =  new Node();\n\"",
            "\"                int mid = (l + r) / 2;\n\"",
            "\"                left->l  = l;\n\"",
            "\"                left->r  = mid;\n\"",
            "\"                right->l = mid + 1;\n\"",
            "\"                right->r = r; \n\"",
            "\"            }\n\"",
            "\"            return;\n\"",
            "\"        }\n\"",
            "\"    };\n\"",
            "\"    Node *tree;\n\"",
            "\"\n\"",
            "\"    DynamicSegment() { tree = new Node(); }\n\"",
            "\"    void update(Node *cur, int x, T data){\n\"",
            "\"        if(x < cur->l || cur->r < x)return;\n\"",
            "\"        if(cur->l == cur->r)return cur->data = data, (void)0;\n\"",
            "\"        cur->extend();\n\"",
            "\"        update(cur->left, x, data);\n\"",
            "\"        update(cur->right, x, data);\n\"",
            "\"        cur->data = mergeNode(cur->left->data, cur->right->data);\n\"",
            "\"    }\n\"",
            "\"    void update(int x, T data){ update(tree, x, data); }\n\"",
            "\"\n\"",
            "\"    T query(Node *cur, int l, int r){\n\"",
            "\"        if(cur->l > cur->r || cur->r < l || cur->l > r)return T(0);\n\"",
            "\"        if(l <= cur->l && cur->r <= r)return cur->data;\n\"",
            "\"        cur->extend();\n\"",
            "\"        return mergeNode(query(cur->left, l, r), query(cur->right, l, r));\n\"",
            "\"    }\n\"",
            "\"    T query(int l, int r){ return query(tree, l, r); }\n\"",
            "\"    T merge(T, T);\n\"",
            "\"};\""
        ],
        "description": "Dynamic Segment Tree"
    },
    "Fast Input": {
        "prefix": [
            "fastinput"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/1000\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.02 01:22 AM (KST)\n\"",
            "\" */\n\"",
            "\"#define BUFFERMAX 1 << 19\n\"",
            "\"struct IO {\n\"",
            "\"    char buf[BUFFERMAX];\n\"",
            "\"\n\"",
            "\"    char _read() {\n\"",
            "\"        static int idx = BUFFERMAX;\n\"",
            "\"        if(idx == BUFFERMAX){\n\"",
            "\"            fread(buf, 1, BUFFERMAX, stdin);\n\"",
            "\"            idx = 0;\n\"",
            "\"        }\n\"",
            "\"        return buf[idx++];\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    char readChar() {\n\"",
            "\"        char ret = _read();\n\"",
            "\"        while(ret == 10 || ret == 32) ret = _read();\n\"",
            "\"        return ret;\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    string readString() {\n\"",
            "\"        string ret = \"\";\n\"",
            "\"        char now = _read();\n\"",
            "\"        while(now == 10 || now == 32) now = _read();\n\"",
            "\"        while(true) {\n\"",
            "\"            ret += now;\n\"",
            "\"            now = _read();\n\"",
            "\"            if(now == 10 || now == 32) break;\n\"",
            "\"        }\n\"",
            "\"        return ret;\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    template<typename T> T readInt() {\n\"",
            "\"        T ret = 0;\n\"",
            "\"        bool minus = false;\n\"",
            "\"        char now = _read();\n\"",
            "\"        while(now == 10 || now == 32) now = _read();\n\"",
            "\"        if(now == '-') minus = true, now = _read();\n\"",
            "\"        while(48 <= now && now <= 57) {\n\"",
            "\"            ret = ret * 10 + now - 48;\n\"",
            "\"            now = _read();\n\"",
            "\"        }\n\"",
            "\"        if(minus) ret *= -1;\n\"",
            "\"        return ret;\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    void read(int &x) { x = readInt<int>(); }\n\"",
            "\"    void read(long long &x) { x = readInt<long long>(); }\n\"",
            "\"    void read(char &x) { x = readChar(); }\n\"",
            "\"    void read(string &x) { x = readString(); }\n\"",
            "\"    template<typename Type, typename... Types> void read(Type &arg, Types &...args) {  read(arg); read(args...); }\n\"",
            "\"} io;\n\"",
            "\"\n\"",
            "\"template<typename T>\n\"",
            "\"IO& operator>> (IO& in, T &x) { in.read(x); return in; }\n\"",
            "\"\n\"",
            "\"#define cin io\n\"",
            "\"#define istream IO\""
        ],
        "description": "Fast Input"
    },
    "Fenwick Tree": {
        "prefix": [
            "fenwick",
            "fenwick_tree"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/2042\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 03:12 PM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T>\n\"",
            "\"struct Fenwick{\n\"",
            "\"    vector<T> tree, input;\n\"",
            "\"    int siz;\n\"",
            "\"    \n\"",
            "\"    Fenwick(){ }\n\"",
            "\"    Fenwick(int N){ setSize(N); }\n\"",
            "\"\n\"",
            "\"    void setSize(int N){\n\"",
            "\"        siz  = N;\n\"",
            "\"        tree = input = vector<T>(siz + 1);\n\"",
            "\"    }\n\"",
            "\"    void putItem(int idx, T data){ input[idx] = data; __update(idx, data); }\n\"",
            "\"    void __update(int idx, T data){\n\"",
            "\"        for(; idx <= siz; idx += (idx & -idx)) tree[idx] += data;\n\"",
            "\"    }\n\"",
            "\"    void update(int idx, T data, bool add=false){\n\"",
            "\"        if(add) __update(idx, data), input[idx] += data;\n\"",
            "\"        else __update(idx, data - input[idx]), input[idx] = data;\n\"",
            "\"    }\n\"",
            "\"    T query(int idx) { \n\"",
            "\"        T ret = 0;\n\"",
            "\"        for(; idx ; idx -= (idx & -idx)) ret += tree[idx];\n\"",
            "\"        return ret;\n\"",
            "\"    }\n\"",
            "\"    T query(int l, int r){ return query(r) - query(l - 1); }\n\"",
            "\"};\""
        ],
        "description": "Fenwick Tree"
    },
    "Floyd": {
        "prefix": [
            "floyd"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/11780\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.02 03:34 AM (KST)\n\"",
            "\" */\n\"",
            "\"using namespace std;\n\"",
            "\"\n\"",
            "\"template<typename T> struct Floyd {\n\"",
            "\"    const T INF = numeric_limits<T>::max() / 2;\n\"",
            "\"    vector<vector<T>> DP;\n\"",
            "\"    vector<vector<int>> path;\n\"",
            "\"    int N;\n\"",
            "\"    Floyd(int N) : N(N) {\n\"",
            "\"        DP = vector<vector<T>>(N, vector<T>(N, INF));\n\"",
            "\"        path = vector<vector<int>>(N, vector<int>(N, -1));\n\"",
            "\"        for (int i = 0; i < N; ++i) DP[i][i] = 0;\n\"",
            "\"    }\n\"",
            "\"    void addEdge(int u, int v, T w) { DP[u][v] += w; }\n\"",
            "\"    void setEdge(int u, int v, T w) { DP[u][v]  = w; }\n\"",
            "\"    void minEdge(int u, int v, T w) { DP[u][v]  = min(DP[u][v], w); }\n\"",
            "\"    void floyd() {\n\"",
            "\"        for(int k = 0; k < N; ++k) {\n\"",
            "\"            for(int i = 0; i < N; ++i) {\n\"",
            "\"                for(int j = 0; j < N; ++j) {\n\"",
            "\"                    if(DP[i][j] > DP[i][k] + DP[k][j]) {\n\"",
            "\"                        DP[i][j] = DP[i][k] + DP[k][j];\n\"",
            "\"                        path[i][j] = k;\n\"",
            "\"                    }\n\"",
            "\"                }\n\"",
            "\"            }\n\"",
            "\"        }\n\"",
            "\"    }\n\"",
            "\"    vector<int> GetPath(int S, int E) {\n\"",
            "\"        vector<int> ret;\n\"",
            "\"        if(S == E || DP[S][E] == INF)return ret;\n\"",
            "\"        function<void(int,int)> findPath = [&](int s, int e) -> void {\n\"",
            "\"            int pre = path[s][e];\n\"",
            "\"            if(pre == -1) return;\n\"",
            "\"            findPath(s,pre); \n\"",
            "\"            ret.push_back(pre);\n\"",
            "\"            findPath(pre,e);\n\"",
            "\"        };\n\"",
            "\"        ret.push_back(S);\n\"",
            "\"        findPath(S, E);\n\"",
            "\"        ret.push_back(E);\n\"",
            "\"        return ret;\n\"",
            "\"    }\n\"",
            "\"    vector<T>& operator[](const int &idx) { return DP[idx]; }\n\"",
            "\"};\""
        ],
        "description": "Floyd"
    },
    "Graph": {
        "prefix": [
            "graph"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/1260\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.02 03:20 AM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T> struct Graph {\n\"",
            "\"    vector<vector<T>> G;\n\"",
            "\"    Graph(int N) { G.resize(N + 1); }\n\"",
            "\"    void addEdge(int u, T data) { G[u].emplace_back(data); }\n\"",
            "\"    int size() { return (int)G.size(); }\n\"",
            "\"    vector<T>& operator[](const int &idx) { return G[idx]; }\n\"",
            "\"};\""
        ],
        "description": "Graph"
    },
    "Hashing": {
        "prefix": [
            "hashing"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/21162\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.02 02:35 AM (KST)\n\"",
            "\" */\n\"",
            "\"template<long long C, long long HASH_MOD> struct Hashing {\n\"",
            "\"    vector<long long> H, B;\n\"",
            "\"    template<typename T> void build(const T& S) {\n\"",
            "\"        H.resize(S.size() + 1);\n\"",
            "\"        B.resize(S.size() + 1); B[0] = 1;\n\"",
            "\"        for(int i = 1; i <= (int)S.size(); ++i) H[i] = (H[i - 1] * C + S[i - 1]) % HASH_MOD;\n\"",
            "\"        for(int i = 1; i <= (int)S.size(); ++i) B[i] = B[i - 1] * C % HASH_MOD;\n\"",
            "\"    }\n\"",
            "\"    long long get(int s, int e) {\n\"",
            "\"        long long ret = (H[e] - H[s - 1] * B[e - s + 1]) % HASH_MOD;\n\"",
            "\"        if(ret < 0) ret += HASH_MOD;\n\"",
            "\"        return ret;\n\"",
            "\"    }\n\"",
            "\"    void chk_setting() { assert(gcd(C, HASH_MOD) == 1); }\n\"",
            "\"};\n\""
        ],
        "description": "Hashing"
    },
    "Heavy Light Decomposition": {
        "prefix": [
            "hld",
            "heavy_light_decomposition"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/13510\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.02 09:15 AM (KST)\n\"",
            "\" */\n\"",
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/1260\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.02 03:20 AM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T> struct Graph {\n\"",
            "\"    vector<vector<T>> G;\n\"",
            "\"    Graph(int N) { G.resize(N + 1); }\n\"",
            "\"    void addEdge(int u, T data) { G[u].emplace_back(data); }\n\"",
            "\"    int size() { return (int)G.size(); }\n\"",
            "\"    vector<T>& operator[](const int &idx) { return G[idx]; }\n\"",
            "\"};\n\"",
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/2042\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 09:57 PM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T>\n\"",
            "\"struct Segment {\n\"",
            "\"    vector<T> tree;\n\"",
            "\"    int siz;\n\"",
            "\"\n\"",
            "\"    Segment(int N = 1 << 17) {\n\"",
            "\"        for(siz = 1; siz < N; siz <<= 1);\n\"",
            "\"        tree = vector<T>(siz << 1);\n\"",
            "\"    }\n\"",
            "\"    void update(int idx, T data) {\n\"",
            "\"        tree[idx += siz] = data;\n\"",
            "\"        while(idx >>= 1) tree[idx] = merge(tree[idx << 1], tree[idx << 1 | 1]);\n\"",
            "\"    }\n\"",
            "\"    T query(int l, int r, int s, int e, int pos) {\n\"",
            "\"        if(s <= l && r <= e) return tree[pos];\n\"",
            "\"        if(e <  l || r <  s) return 0;\n\"",
            "\"        int mid = (l + r) / 2;\n\"",
            "\"        return merge(query(l, mid, s, e, pos << 1) , query(mid + 1, r, s, e, pos << 1 | 1));\n\"",
            "\"    }\n\"",
            "\"    T query(int s, int e) { return query(0, siz - 1, s, e, 1); }\n\"",
            "\"    T merge(T, T);\n\"",
            "\"};\n\"",
            "\"\n\"",
            "\"struct HLD {\n\"",
            "\"    Graph<int> G;\n\"",
            "\"    vector<int> par, top, dep, siz, in, out;\n\"",
            "\"    Segment<int> seg;\n\"",
            "\"    int id;\n\"",
            "\"    HLD(Graph<int> G):G(G) {\n\"",
            "\"        int N = (int)G.size();\n\"",
            "\"        siz = par = top = dep = in = out = vector<int>(N);\n\"",
            "\"        seg = Segment<int>(N);\n\"",
            "\"        id = 0;\n\"",
            "\"    }\n\"",
            "\"    void dfs(int cur=1, int prev=0) {\n\"",
            "\"        siz[cur] = 1;\n\"",
            "\"        par[cur] = prev;\n\"",
            "\"        dep[cur] = dep[prev] + 1;\n\"",
            "\"        for(int &nxt : G[cur]) {\n\"",
            "\"            if(nxt == prev) continue;\n\"",
            "\"            dfs(nxt, cur);\n\"",
            "\"            siz[cur] += siz[nxt];\n\"",
            "\"            if(siz[nxt] > siz[G[cur][0]]) swap(nxt, G[cur][0]);\n\"",
            "\"        }\n\"",
            "\"    }\n\"",
            "\"    void dfs2(int cur=1, int prev=0) {\n\"",
            "\"        in[cur] = ++id;\n\"",
            "\"        if(cur == 1) top[cur] = 1;\n\"",
            "\"        for(int nxt: G[cur]) {\n\"",
            "\"            if(nxt == prev)continue;\n\"",
            "\"            top[nxt] = (nxt == G[cur][0] ? top[cur] : nxt);\n\"",
            "\"            dfs2(nxt, cur);\n\"",
            "\"        }\n\"",
            "\"        out[cur] = id;\n\"",
            "\"    }\n\"",
            "\"    void update(int, int);\n\"",
            "\"    int query(int, int);\n\"",
            "\"};\n\""
        ],
        "description": "Heavy Light Decomposition"
    },
    "KMP": {
        "prefix": [
            "kmp"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/1786\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.02 03:04 AM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T> struct KMP {\n\"",
            "\"    vector<int> fail;\n\"",
            "\"    vector<int> failure(const T &Q) {\n\"",
            "\"        fail.resize((int)Q.size() + 1);\n\"",
            "\"        for(int i = 1, j = 0; i < (int)Q.size(); ++i) {\n\"",
            "\"            while(j > 0 && Q[i] != Q[j]) j = fail[j - 1];\n\"",
            "\"            if(Q[i] == Q[j]) fail[i] = ++j;\n\"",
            "\"        }\n\"",
            "\"        return fail;\n\"",
            "\"    }\n\"",
            "\"    vector<int> kmp(const T& P, const T& Q) {\n\"",
            "\"        if(fail.size() == 0) failure(Q);\n\"",
            "\"        vector<int> res;\n\"",
            "\"        for(int i = 0, j = 0; i < (int)P.size(); ++i) {\n\"",
            "\"            while(j > 0 && P[i] != Q[j]) j = fail[j - 1];\n\"",
            "\"            if(P[i] == Q[j]) {\n\"",
            "\"                if(j + 1 == (int)Q.size()) res.push_back(i - (int)Q.size() + 1), j = fail[j];\n\"",
            "\"                else ++j;\n\"",
            "\"            }\n\"",
            "\"        }\n\"",
            "\"        return res;\n\"",
            "\"    }\n\"",
            "\"};\n\""
        ],
        "description": "KMP"
    },
    "NTT": {
        "prefix": [
            "ntt"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/15576\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 12:31 AM (KST)\n\"",
            "\" */\n\"",
            "\"const long long W = 3;\n\"",
            "\"const long long MOD = 998244353;\n\"",
            "\"\n\"",
            "\"void _NTT(vector<long long> &V, bool inv = false) {\n\"",
            "\"    int N = (int)V.size();\n\"",
            "\"    vector<long long> root(N >> 1);\n\"",
            "\"    for(int i = 1, j = 0; i < N; i++) {\n\"",
            "\"        int bit = (N >> 1);\n\"",
            "\"        for(; j >= bit; bit >>= 1) j &= ~bit; \n\"",
            "\"        j |= bit;\n\"",
            "\"        if(i < j) swap(V[i], V[j]);\n\"",
            "\"    }\n\"",
            "\"    long long angle = power(W, (MOD - 1) / N, MOD);\n\"",
            "\"    if(inv) angle = power(angle, MOD - 2, MOD);\n\"",
            "\"    root[0] = 1;\n\"",
            "\"    for(int i = 1; i * 2 < N; i++) root[i] = root[i - 1] * angle % MOD;\n\"",
            "\"    for(int i = 2; i <= N; i <<= 1) {\n\"",
            "\"        long long step = N / i;\n\"",
            "\"        for(int j = 0; j < N; j += i) {\n\"",
            "\"            for(int k = 0; k * 2 < i; k++) {\n\"",
            "\"                long long u = V[j | k];\n\"",
            "\"                long long v = V[j | k | i >> 1] * root[step * k] % MOD;\n\"",
            "\"                V[j | k] = (u + v) % MOD;\n\"",
            "\"                V[j | k | i >> 1] = (u - v) % MOD;\n\"",
            "\"                if(V[j | k | i >> 1] < 0) V[j | k | i >> 1] += MOD;\n\"",
            "\"            }\n\"",
            "\"        }\n\"",
            "\"    }\n\"",
            "\"    if(inv) {\n\"",
            "\"        long long t = power(1LL * N, MOD - 2, MOD);\n\"",
            "\"        for(int i = 0; i < N; i++) V[i] = (V[i] * t) % MOD;\n\"",
            "\"    }\n\"",
            "\"}\n\"",
            "\"\n\"",
            "\"vector<long long> multiply(const vector<long long> &vec1, const vector<long long> &vec2) { \n\"",
            "\"    vector<long long> A(vec1.begin(), vec1.end());\n\"",
            "\"    vector<long long> B(vec2.begin(), vec2.end());\n\"",
            "\"    int L = (int)vec1.size(), R = (int)vec2.size(), N;\n\"",
            "\"    for(N = 2; N < L + R; N <<= 1);\n\"",
            "\"    A.resize(N); B.resize(N);\n\"",
            "\"    _NTT(A); _NTT(B);\n\"",
            "\"    for(int i = 0; i < N; i++) A[i] = A[i] * B[i] % MOD;\n\"",
            "\"    _NTT(A, true);\n\"",
            "\"    return A;\n\"",
            "\"}\""
        ],
        "description": "NTT"
    },
    "Palindrome Tree": {
        "prefix": [
            "palindrome_tree",
            "eertree"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/10066\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.02 02:55 AM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T = int> struct PalindromeTree {\n\"",
            "\"    struct Node {\n\"",
            "\"        int len, suffix_link;\n\"",
            "\"        T cnt;\n\"",
            "\"        map<char, int> nxt;\n\"",
            "\"        \n\"",
            "\"        Node() : Node(0, 0) { }\n\"",
            "\"        Node(int _len, int _link) {\n\"",
            "\"            len = _len; suffix_link = _link;\n\"",
            "\"            cnt = T();\n\"",
            "\"        }\n\"",
            "\"    };\n\"",
            "\"\n\"",
            "\"    vector<Node> tree;\n\"",
            "\"    int cnt, last_suffix;\n\"",
            "\"\n\"",
            "\"    PalindromeTree(int N) {\n\"",
            "\"        tree.resize(N);\n\"",
            "\"        cnt = last_suffix = 2;\n\"",
            "\"        tree[1] = Node(-1, 1);\n\"",
            "\"        tree[2] = Node(0, 1);\n\"",
            "\"    }\n\"",
            "\"    void init(const string &S) {\n\"",
            "\"        auto chk = [&](int idx, int cur) {\n\"",
            "\"            return idx - tree[cur].len - 1 >= 0 && S[idx - tree[cur].len - 1] == S[idx];\n\"",
            "\"        };\n\"",
            "\"        for(int i = 0; i < (int)S.size(); ++i) {\n\"",
            "\"            int cur = last_suffix;\n\"",
            "\"            while(!chk(i, cur)) cur = tree[cur].suffix_link;\n\"",
            "\"            if(tree[cur].nxt.count(S[i])) {\n\"",
            "\"                last_suffix = tree[cur].nxt[S[i]];\n\"",
            "\"                ++ tree[last_suffix].cnt;\n\"",
            "\"                continue;\n\"",
            "\"            }\n\"",
            "\"            last_suffix = tree[cur].nxt[S[i]] = ++cnt;\n\"",
            "\"            int nxt = cnt;\n\"",
            "\"            tree[nxt].len = tree[cur].len + 2;\n\"",
            "\"            ++ tree[nxt].cnt;\n\"",
            "\"            if(tree[nxt].len == 1) {\n\"",
            "\"                tree[nxt].suffix_link = 2;\n\"",
            "\"                continue;\n\"",
            "\"            }\n\"",
            "\"            while(cur > 1) {\n\"",
            "\"                cur = tree[cur].suffix_link;\n\"",
            "\"                if(chk(i, cur)) {\n\"",
            "\"                    tree[nxt].suffix_link = tree[cur].nxt[S[i]];\n\"",
            "\"                    break;\n\"",
            "\"                }\n\"",
            "\"            }\n\"",
            "\"        }\n\"",
            "\"    }\n\"",
            "\"    Node& operator[](const int &idx) { return tree[idx]; }\n\"",
            "\"};\""
        ],
        "description": "Palindrome Tree"
    },
    "Persistent Segment Tree": {
        "prefix": [
            "persistent_segment_tree",
            "pst"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/7469\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 03:21 PM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T>\n\"",
            "\"struct PST{\n\"",
            "\"    struct Node{\n\"",
            "\"        Node *left, *right;\n\"",
            "\"        T data;\n\"",
            "\"        Node(Node *l = nullptr, Node *r = nullptr, T v=0):left(l), right(r), data(v) { }\n\"",
            "\"        Node *push(int l, int r, int x, T _data) {\n\"",
            "\"            if(r < x || x < l) return this;\n\"",
            "\"            if(l == r) return new Node(0, 0, this->data + _data);\n\"",
            "\"            int mid = l + (r - l) / 2;\n\"",
            "\"            Node *L = left->push(l, mid, x, _data);\n\"",
            "\"            Node *R = right->push(mid + 1, r, x, _data);\n\"",
            "\"            return new Node(L, R, L->data + R->data);\n\"",
            "\"        }\n\"",
            "\"    };\n\"",
            "\"    Node *roots[100002];\n\"",
            "\"    int siz;\n\"",
            "\"\n\"",
            "\"    PST() { setting(); }\n\"",
            "\"    PST(int N) { setting(N); }\n\"",
            "\"    void setting(int N = 2e9 + 10){\n\"",
            "\"        siz = N;\n\"",
            "\"        roots[0] = new Node();\n\"",
            "\"        roots[0]->left = roots[0]->right = roots[0];\n\"",
            "\"    }\n\"",
            "\"    \n\"",
            "\"    void expand(int p){ roots[p] = roots[p - 1]; }\n\"",
            "\"    void update(int p, int idx, T data, bool _expand=false){\n\"",
            "\"        if(_expand) expand(p);\n\"",
            "\"        roots[p] = roots[p]->push(1, siz, idx, data);\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    T query(Node *cur, int l, int r, int s, int e){\n\"",
            "\"        if(s <= l && r <= e)return cur->data;\n\"",
            "\"        if(e <  l || r <  s)return 0;\n\"",
            "\"        int mid = l + (r - l) / 2;\n\"",
            "\"        return query(cur->left, l, mid, s, e) + query(cur->right, mid + 1, r, s, e);\n\"",
            "\"    }\n\"",
            "\"    T query(int s, int e, int p){ return query(roots[p], 1, siz, s, e); }\n\"",
            "\"\n\"",
            "\"    T kth(Node *s, Node *e, int l, int r, int k){\n\"",
            "\"        if(l == r)return l;\n\"",
            "\"        int mid = l + (r - l) / 2;\n\"",
            "\"        T data = e->left->data - s->left->data;\n\"",
            "\"        if(data >= k)return kth(s->left, e->left, l, mid, k);\n\"",
            "\"        return kth(s->right, e->right, mid + 1, r, k - data);\n\"",
            "\"    }\n\"",
            "\"    T kth(int s, int e, int k){ return kth(roots[s], roots[e], 1, siz, k); }\n\"",
            "\"};\""
        ],
        "description": "Persistent Segment Tree"
    },
    "Power": {
        "prefix": [
            "power"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/1629\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 10:44 PM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T, typename modulo>\n\"",
            "\"T power(T a, T b, modulo mod) {\n\"",
            "\"    T ret = 1;\n\"",
            "\"    while(b) {\n\"",
            "\"        if(b & 1) ret = ret * a % mod;\n\"",
            "\"        a = a * a % mod;\n\"",
            "\"        b >>= 1;\n\"",
            "\"    }\n\"",
            "\"    return ret;\n\"",
            "\"}\""
        ],
        "description": "Power"
    },
    "Range Fenwick Tree": {
        "prefix": [
            "range_fenwick_tree",
            "rfenwick"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/10999\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 03:19 PM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T>\n\"",
            "\"struct FenwickRU{ // Fenwick Range Update\n\"",
            "\"    vector<T> tree, add, mul, input;\n\"",
            "\"    int siz;\n\"",
            "\"\n\"",
            "\"    FenwickRU(){ } \n\"",
            "\"    FenwickRU(int N) { setSize(N); }\n\"",
            "\"    void setSize(int N) { \n\"",
            "\"        siz = N;\n\"",
            "\"        tree = add = mul = input = vector<T>(N + 1); \n\"",
            "\"    }\n\"",
            "\"    void putItem(int idx, T data) { update(idx, idx, data), input[idx] = data; }\n\"",
            "\"    void __update(int idx, T _mul, T _add){\n\"",
            "\"        for(; idx <= siz; idx += idx & -idx){\n\"",
            "\"            add[idx] += _add;\n\"",
            "\"            mul[idx] += _mul;\n\"",
            "\"        }\n\"",
            "\"    }\n\"",
            "\"    void update(int l, int r, T data){\n\"",
            "\"        __update(l, data, (l - 1) * -data);\n\"",
            "\"        __update(r + 1, -data, data * r);\n\"",
            "\"    }\n\"",
            "\"    T query(int idx){\n\"",
            "\"        T __add = 0, __mul = 0;\n\"",
            "\"        for(int i = idx; i; i -= i & -i) {\n\"",
            "\"            __add += add[i];\n\"",
            "\"            __mul += mul[i];\n\"",
            "\"        }\n\"",
            "\"        return __mul * idx + __add;\n\"",
            "\"    }\n\"",
            "\"    T query(int l, int r){ return query(r) - query(l - 1); }\n\"",
            "\"};\""
        ],
        "description": "Range Fenwick Tree"
    },
    "SCC": {
        "prefix": [
            "scc"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/2150\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 12:35 AM (KST)\n\"",
            "\" */\n\"",
            "\"struct SCC{\n\"",
            "\"    bool _set_size;\n\"",
            "\"    stack<int> st;\n\"",
            "\"    vector<vector<int>> adj, scc;\n\"",
            "\"    vector<int> d, used;\n\"",
            "\"    int id, N;\n\"",
            "\"\n\"",
            "\"    SCC():_set_size(false) {}\n\"",
            "\"    SCC(int _N){\n\"",
            "\"        _set_size = true;\n\"",
            "\"        setSize(_N);\n\"",
            "\"    }\n\"",
            "\"    void setSize(int _N) {\n\"",
            "\"        _set_size = true;\n\"",
            "\"        N = _N;\n\"",
            "\"        id = 0;\n\"",
            "\"        adj = vector<vector<int>>(N + 1);\n\"",
            "\"        d = used = vector<int>(N + 1);\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    void addEdge(int a, int b, bool bidirected = false) {\n\"",
            "\"        adj[a].push_back(b);\n\"",
            "\"        if(bidirected) adj[b].push_back(a);\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    int dfs(int x){\n\"",
            "\"        d[x] = ++id;\n\"",
            "\"\n\"",
            "\"        st.push(x);\n\"",
            "\"        int par = d[x];\n\"",
            "\"        for(const auto &i : adj[x]){\n\"",
            "\"            if(!d[i])par = min(par, dfs(i));\n\"",
            "\"            else if(!used[i])par = min(par, d[i]);\n\"",
            "\"        }\n\"",
            "\"\n\"",
            "\"        if(par == d[x]){\n\"",
            "\"            vector<int> now;\n\"",
            "\"            while(!st.empty()){\n\"",
            "\"                int t = st.top();st.pop();\n\"",
            "\"                used[t] = true;\n\"",
            "\"                now.push_back(t);\n\"",
            "\"                if(t == x)break;\n\"",
            "\"            }\n\"",
            "\"            scc.push_back(now);\n\"",
            "\"        }\n\"",
            "\"        return par;\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    void run(){ for(int i=1;i<=N;i++)if(!d[i])dfs(i); }\n\"",
            "\"    int getSize() { return (int)scc.size(); }\n\"",
            "\"};\""
        ],
        "description": "SCC"
    },
    "Segment Tree with Lazy Propagation": {
        "prefix": [
            "seglazy",
            "segmentlazy"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/10999\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 09:56 PM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T>\n\"",
            "\"struct SegmentLazy {\n\"",
            "\"    vector<T> tree, lazy;\n\"",
            "\"    int siz;\n\"",
            "\"\n\"",
            "\"    SegmentLazy(int N = 1 << 17) {\n\"",
            "\"        for(siz = 1; siz < N; siz <<= 1);\n\"",
            "\"        lazy = tree = vector<T>(siz << 1);\n\"",
            "\"    }\n\"",
            "\"    void putItem(int idx, T data) { tree[idx + siz] = data; }\n\"",
            "\"    void build() {\n\"",
            "\"        for(int i = siz - 1; i; --i) tree[i] = merge(tree[i << 1], tree[i << 1 | 1]);\n\"",
            "\"    }\n\"",
            "\"    void propagate(int l, int r, int pos) {\n\"",
            "\"        if(!lazy[pos]) return;\n\"",
            "\"        if(l != r) {\n\"",
            "\"            lazy[pos << 1] = merge(lazy[pos << 1], lazy[pos]);\n\"",
            "\"            lazy[pos << 1 | 1] = merge(lazy[pos << 1 | 1], lazy[pos]);\n\"",
            "\"        }\n\"",
            "\"        tree[pos] += lazy[pos] * (r - l + 1);\n\"",
            "\"        lazy[pos] = 0;\n\"",
            "\"    }\n\"",
            "\"    void update(int l, int r, int s, int e, int pos, T data) {\n\"",
            "\"        if(s <= l && r <= e) {\n\"",
            "\"            lazy[pos] += data;\n\"",
            "\"            propagate(l, r, pos);\n\"",
            "\"            return;\n\"",
            "\"        }\n\"",
            "\"        propagate(l, r, pos);\n\"",
            "\"        if(e <  l || r <  s) return;\n\"",
            "\"        int mid = (l + r) / 2;\n\"",
            "\"        update(l, mid, s, e, pos << 1, data);\n\"",
            "\"        update(mid + 1, r, s, e, pos << 1 | 1, data);\n\"",
            "\"        tree[pos] = merge(tree[pos << 1], tree[pos << 1 | 1]);\n\"",
            "\"    }\n\"",
            "\"    void update(int s, int e, T data) { update(0, siz - 1, s, e, 1, data); }\n\"",
            "\"    T query(int l, int r, int s, int e, int pos) {\n\"",
            "\"        propagate(l, r, pos);\n\"",
            "\"        if(s <= l && r <= e) return tree[pos];\n\"",
            "\"        if(e <  l || r <  s) return 0;\n\"",
            "\"        int mid = (l + r) / 2;\n\"",
            "\"        return merge(query(l, mid, s, e, pos << 1), query(mid + 1, r, s, e, pos << 1 | 1));\n\"",
            "\"    }\n\"",
            "\"    T query(int s, int e) { return query(0, siz - 1, s, e, 1); }\n\"",
            "\"    T merge(T, T);\n\"",
            "\"};\""
        ],
        "description": "Segment Tree with Lazy Propagation"
    },
    "Segment Tree": {
        "prefix": [
            "segment",
            "segtree"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/2042\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 09:57 PM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T>\n\"",
            "\"struct Segment {\n\"",
            "\"    vector<T> tree;\n\"",
            "\"    int siz;\n\"",
            "\"\n\"",
            "\"    Segment(int N = 1 << 17) {\n\"",
            "\"        for(siz = 1; siz < N; siz <<= 1);\n\"",
            "\"        tree = vector<T>(siz << 1);\n\"",
            "\"    }\n\"",
            "\"    void update(int idx, T data) {\n\"",
            "\"        tree[idx += siz] = data;\n\"",
            "\"        while(idx >>= 1) tree[idx] = merge(tree[idx << 1], tree[idx << 1 | 1]);\n\"",
            "\"    }\n\"",
            "\"    T query(int l, int r, int s, int e, int pos) {\n\"",
            "\"        if(s <= l && r <= e) return tree[pos];\n\"",
            "\"        if(e <  l || r <  s) return 0;\n\"",
            "\"        int mid = (l + r) / 2;\n\"",
            "\"        return merge(query(l, mid, s, e, pos << 1) , query(mid + 1, r, s, e, pos << 1 | 1));\n\"",
            "\"    }\n\"",
            "\"    T query(int s, int e) { return query(0, siz - 1, s, e, 1); }\n\"",
            "\"    T merge(T, T);\n\"",
            "\"};\""
        ],
        "description": "Segment Tree"
    },
    "Splay Tree": {
        "prefix": [
            "splay"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/3444\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.10.29 09:12 PM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T, const int node_siz = 500000>\n\"",
            "\"struct SplayTree {\n\"",
            "\"    struct Data {\n\"",
            "\"        int sz;\n\"",
            "\"        T mn, mx, sum, value;\n\"",
            "\"        bool flip, dummy;\n\"",
            "\"\n\"",
            "\"        Data(T _value = 0) : value(_value) {\n\"",
            "\"            init();\n\"",
            "\"            flip = dummy = false;\n\"",
            "\"        }\n\"",
            "\"\n\"",
            "\"        void init() {\n\"",
            "\"            sz = 1;\n\"",
            "\"            mn = mx = sum = value;\n\"",
            "\"        }\n\"",
            "\"    };\n\"",
            "\"\n\"",
            "\"    struct Node {\n\"",
            "\"        Node *l, *r, *p;\n\"",
            "\"        Data data;\n\"",
            "\"\n\"",
            "\"        Node():Node(0){}\n\"",
            "\"        Node(T _value) : Node(_value, nullptr) {}\n\"",
            "\"\n\"",
            "\"        Node(T _value, Node *_p) {\n\"",
            "\"            p = _p;\n\"",
            "\"            l = r = nullptr;\n\"",
            "\"            data = Data(_value);\n\"",
            "\"        }\n\"",
            "\"\n\"",
            "\"        bool is_left() { return this == p->l; }\n\"",
            "\"\n\"",
            "\"        bool is_right() { return this == p->r; }\n\"",
            "\"\n\"",
            "\"        bool is_root() { return p == nullptr || (!is_left() && !is_right()); }\n\"",
            "\"\n\"",
            "\"        void merge(Data o) {\n\"",
            "\"            data.sz += o.sz;\n\"",
            "\"            data.mn = min(data.mn, o.mn);\n\"",
            "\"            data.mx = max(data.mx, o.mx);\n\"",
            "\"            data.sum += o.sum;\n\"",
            "\"        }\n\"",
            "\"\n\"",
            "\"        void update() {\n\"",
            "\"            data.init();\n\"",
            "\"            if (l) merge(l->data);\n\"",
            "\"            if (r) merge(r->data);\n\"",
            "\"        }\n\"",
            "\"\n\"",
            "\"        void push() {\n\"",
            "\"            if (data.flip == false) return;\n\"",
            "\"            swap(l, r);\n\"",
            "\"            data.flip = false;\n\"",
            "\"            if (l) l->data.flip ^= 1;\n\"",
            "\"            if (r) r->data.flip ^= 1;\n\"",
            "\"        }\n\"",
            "\"    };\n\"",
            "\"\n\"",
            "\"    Node *root;\n\"",
            "\"    Node *node[node_siz];\n\"",
            "\"\n\"",
            "\"    SplayTree() {}\n\"",
            "\"\n\"",
            "\"    SplayTree(int N, const vector<T> &V) { init(N, V); }\n\"",
            "\"\n\"",
            "\"    void init(int N, const vector<T> &V) {\n\"",
            "\"        const T INF = numeric_limits<T>::max() / 2;\n\"",
            "\"        Node *cur = root = new Node(-INF);\n\"",
            "\"        for (int i = 1; i <= N; ++i) {\n\"",
            "\"            node[V[i]] = cur->r = new Node(V[i], cur);\n\"",
            "\"            cur = cur->r;\n\"",
            "\"        }\n\"",
            "\"        node[N + 1] = cur->r = new Node(INF, cur);\n\"",
            "\"        root->data.dummy = cur->r->data.dummy = true;\n\"",
            "\"        for (int i = N + 1; i >= 1; --i) node[i]->update();\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    void rotate(Node *cur) {\n\"",
            "\"        if (cur->p == nullptr) return;\n\"",
            "\"        Node *p = cur->p;\n\"",
            "\"        p->push();\n\"",
            "\"        cur->push();\n\"",
            "\"\n\"",
            "\"        if (cur->is_left()) {\n\"",
            "\"            if (cur->r) cur->r->p = p;\n\"",
            "\"            p->l = cur->r;\n\"",
            "\"            cur->r = p;\n\"",
            "\"        }\n\"",
            "\"        else {\n\"",
            "\"            if (cur->l) cur->l->p = p;\n\"",
            "\"            p->r = cur->l;\n\"",
            "\"            cur->l = p;\n\"",
            "\"        }\n\"",
            "\"\n\"",
            "\"        if (!p->is_root()) {\n\"",
            "\"            if (p->is_left()) p->p->l = cur;\n\"",
            "\"            else p->p->r = cur;\n\"",
            "\"        }\n\"",
            "\"        else root = cur;\n\"",
            "\"\n\"",
            "\"        cur->p = p->p;\n\"",
            "\"        p->p = cur;\n\"",
            "\"\n\"",
            "\"        p->update();\n\"",
            "\"        cur->update();\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    Node *splay(Node *cur, Node *g = nullptr) {\n\"",
            "\"        while (!cur->is_root() && cur->p != g) {\n\"",
            "\"            if (cur->p->is_root() || cur->p->p == g) {\n\"",
            "\"                rotate(cur);\n\"",
            "\"                continue;\n\"",
            "\"            }\n\"",
            "\"            if (cur->p->p != g) rotate((cur->is_left() ^ cur->p->is_left()) ? cur : cur->p);\n\"",
            "\"            rotate(cur);\n\"",
            "\"        }\n\"",
            "\"        if (g == nullptr) root = cur;\n\"",
            "\"        return root;\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    Node *kth(int k) {\n\"",
            "\"        Node *cur = root;\n\"",
            "\"        cur->push();\n\"",
            "\"        while (true) {\n\"",
            "\"            while (cur->l && cur->l->data.sz > k) {\n\"",
            "\"                cur = cur->l;\n\"",
            "\"                cur->push();\n\"",
            "\"            }\n\"",
            "\"            if (cur->l) k -= cur->l->data.sz;\n\"",
            "\"            if (!k--) break;\n\"",
            "\"            cur = cur->r;\n\"",
            "\"            cur->push();\n\"",
            "\"        }\n\"",
            "\"        return splay(cur);\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    Node *gather(int l, int r) {\n\"",
            "\"        Node *Left = kth(r + 1);\n\"",
            "\"        Node *Right = kth(l - 1);\n\"",
            "\"        return splay(Left, Right)->r->l;\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    Node *flip(int l, int r) {\n\"",
            "\"        Node *cur = gather(l, r);\n\"",
            "\"        cur->data.flip ^= 1;\n\"",
            "\"        return cur;\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    Node *shift(int l, int r, int x) {\n\"",
            "\"        Node *cur = gather(l, r);\n\"",
            "\"        if (x >= 0) {\n\"",
            "\"            x %= (r - l + 1);\n\"",
            "\"            if (x == 0) return cur;\n\"",
            "\"            flip(l, r);\n\"",
            "\"            flip(l, l + x - 1);\n\"",
            "\"            flip(l + x, r);\n\"",
            "\"        }\n\"",
            "\"        else {\n\"",
            "\"            x *= -1;\n\"",
            "\"            x %= (r - l + 1);\n\"",
            "\"            flip(l, r);\n\"",
            "\"            flip(l, r - x);\n\"",
            "\"            flip(r - x + 1, r);\n\"",
            "\"        }\n\"",
            "\"        return gather(l, r);\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    int operator[](const int k) {\n\"",
            "\"        return splay(node[k])->l->data.sz;\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    // Debuging\n\"",
            "\"    void inorder(Node *cur) {\n\"",
            "\"        if(cur == nullptr) return;\n\"",
            "\"        cur->push();\n\"",
            "\"        inorder(cur->l);\n\"",
            "\"        if (cur->data.dummy == false) cout << cur->data << ' ';\n\"",
            "\"        inorder(cur->r);\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    void inorder() { inorder(root); }\n\"",
            "\"};\""
        ],
        "description": "Splay Tree"
    },
    "Suffix Array": {
        "prefix": [
            "sa",
            "suffix_array"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/9248\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.02 01:54 AM (KST)\n\"",
            "\" */\n\"",
            "\"template<typename T> struct SuffixArray {\n\"",
            "\"    vector<int> pos, sa, lcp;\n\"",
            "\"    int N;\n\"",
            "\"    SuffixArray(const T& S) {\n\"",
            "\"        N = (int)S.size();\n\"",
            "\"        lcp = pos = sa = vector<int>(N);\n\"",
            "\"        vector<int> tmp(N);\n\"",
            "\"        for(int i = 0; i < N; ++i) sa[i] = i, pos[i] = S[i];\n\"",
            "\"        for(int d = 1; ; d <<= 1) {\n\"",
            "\"            function<bool(int, int)> compare = [&](int a, int b) -> bool {\n\"",
            "\"                if(pos[a] != pos[b]) return pos[a] < pos[b];\n\"",
            "\"                if(a + d < N && b + d < N) return pos[a + d] < pos[b + d];\n\"",
            "\"                return a > b;\n\"",
            "\"            };\n\"",
            "\"            sort(sa.begin(), sa.end(), compare);\n\"",
            "\"            for(int i = 1; i < N; ++i) tmp[i] = tmp[i - 1] + compare(sa[i - 1], sa[i]);\n\"",
            "\"            for(int i = 0; i < N; ++i) pos[sa[i]] = tmp[i];\n\"",
            "\"            if(tmp.back() + 1 == N) break;\n\"",
            "\"        }\n\"",
            "\"        // part of LCP\n\"",
            "\"        for(int i = 0, k = 0; i < N; ++i, k = max(k - 1, 0)) {\n\"",
            "\"            if(!pos[i]) continue;\n\"",
            "\"            while(sa[pos[i] - 1] + k < N && sa[pos[i]] + k < N && S[sa[pos[i] - 1] + k] == S[sa[pos[i]] + k]) ++k;\n\"",
            "\"            lcp[pos[i]] = k;\n\"",
            "\"        }\n\"",
            "\"    }\n\"",
            "\"    vector<int> &get_sa() { return sa; }\n\"",
            "\"    vector<int> &get_lcp() { return lcp; }\n\"",
            "\"};\""
        ],
        "description": "Suffix Array"
    },
    "Trie": {
        "prefix": [
            "trie"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/5052\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 10:40 PM (KST)\n\"",
            "\" */\n\"",
            "\"namespace Trie{\n\"",
            "\"    struct Node{\n\"",
            "\"        char data;\n\"",
            "\"        map<char, Node*> _next;\n\"",
            "\"        Node() { }\n\"",
            "\"        ~Node() { for(auto &i: _next) delete i.second; }\n\"",
            "\"        Node* insert(char x){ if(!find(x)) _next[x] = new Node(); return _next[x]; }\n\"",
            "\"        Node* next(char x){ return _next.count(x) ? _next[x] : nullptr; }\n\"",
            "\"\n\"",
            "\"        bool find(char x){ return _next.count(x) != 0; }\n\"",
            "\"        bool end(){ return _next.count(0); }\n\"",
            "\"    } *root = new Node();\n\"",
            "\"    int words = 0;\n\"",
            "\"\n\"",
            "\"    bool insert(const string &word){\n\"",
            "\"        bool prefix_exist = false;\n\"",
            "\"        Node *cursor = root;\n\"",
            "\"        for (int i = 0; i < (int)word.size(); i++) {\n\"",
            "\"            cursor = cursor->insert(word[i]);\n\"",
            "\"            if(cursor->end()) prefix_exist = true;\n\"",
            "\"        }\n\"",
            "\"        if(!cursor->end()) {\n\"",
            "\"            cursor->insert(0);\n\"",
            "\"            ++words;\n\"",
            "\"            if(cursor->_next.size() > 1) prefix_exist = true;\n\"",
            "\"        }\n\"",
            "\"        return prefix_exist;\n\"",
            "\"    }\n\"",
            "\"    \n\"",
            "\"    bool find(const string &str) {\n\"",
            "\"        Node *cursor = root;\n\"",
            "\"        for (int i = 0; i < (int)str.size(); i++) {\n\"",
            "\"            if(!cursor->find(str[i])) return false;\n\"",
            "\"            cursor = cursor->next(str[i]);\n\"",
            "\"        }\n\"",
            "\"        return cursor->end();\n\"",
            "\"    }\n\"",
            "\"\n\"",
            "\"    void clear() {\n\"",
            "\"        delete root;\n\"",
            "\"        root = new Node();\n\"",
            "\"        words = 0;\n\"",
            "\"    }\n\"",
            "\"}\""
        ],
        "description": "Trie"
    },
    "Union Find": {
        "prefix": [
            "unionfind",
            "uf"
        ],
        "body": [
            "\"/*\n\"",
            "\" * Problem for Testing Template : https://www.acmicpc.net/problem/1717\n\"",
            "\" * Test : Accepted\n\"",
            "\" * Last Updated : 2023.04.01 10:47 PM (KST)\n\"",
            "\" */\n\"",
            "\"struct UnionFind {\n\"",
            "\"    vector<int> uf, siz;\n\"",
            "\"    UnionFind(int N) {\n\"",
            "\"        uf.resize(N, -1);\n\"",
            "\"        siz.resize(N, 1);\n\"",
            "\"    }\n\"",
            "\"    int find(int x) { return uf[x] < 0 ? x : uf[x] = find(uf[x]); }\n\"",
            "\"    bool same(int a, int b) { return find(a) == find(b); }\n\"",
            "\"    bool merge(int a, int b) {\n\"",
            "\"        a = find(a); b = find(b);\n\"",
            "\"        if(a == b) return false;\n\"",
            "\"        uf[b] = a;\n\"",
            "\"        siz[a] += siz[b];\n\"",
            "\"        return true;\n\"",
            "\"    }\n\"",
            "\"};\""
        ],
        "description": "Union Find"
    }
}