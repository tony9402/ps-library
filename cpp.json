{
    "2D Segment Tree": {
        "prefix": [
            "2dseg",
            "2seg"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/11658",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 12:20 AM (KST)",
            " */",
            "template<typename T>",
            "struct Segment2D{",
            "    vector<vector<T>> tree;",
            "    int sizY, sizX;",
            "",
            "    Segment2D() { }",
            "    Segment2D(int y, int x){ setSize(y, x); }",
            "",
            "    void setSize(int y, int x){",
            "        sizY = sizX = 1;",
            "        while(sizY <= y)sizY <<= 1;",
            "        while(sizX <= x)sizX <<= 1;",
            "        tree.resize(2 * sizY);",
            "        for(int i=0; i < sizY * 2; i++) tree[i].resize(2 * sizX);",
            "    }",
            "    void putItem(int y, int x, T data){ tree[sizY + y][sizX + x]  = data; }",
            "    void addItem(int y, int x, T data){ tree[sizY + y][sizX + x] += data; }",
            "    void build(){",
            "        for(int i=sizY;i<sizY*2;i++)",
            "            for(int j=sizX-1;j;j--)",
            "                tree[i][j] = merge(tree[i][j<<1], tree[i][j<<1|1]);",
            "",
            "        for(int i=sizY-1;i;i--)",
            "            for(int j=0;j<2*sizX;j++)",
            "                tree[i][j]=merge(tree[i<<1][j], tree[i<<1|1][j]);",
            "    }",
            "    void update(int y, int x, T data, bool add=false){",
            "        if(add) addItem(y, x, data);",
            "        else    putItem(y, x, data);",
            "        x += sizX; y += sizY;",
            "        for(int i = x >> 1; i; i >>= 1) tree[y][i] = merge(tree[y][i << 1], tree[y][i << 1 | 1]);",
            "",
            "        for(int i = y >> 1; i; i >>= 1)",
            "            for(int j = x; j; j >>= 1)",
            "                tree[i][j] = merge(tree[i<<1][j], tree[i<<1|1][j]);",
            "    }",
            "    T query1D(int y, int l, int r){",
            "        T ret = 0;",
            "        for(l += sizX, r += sizX + 1; l < r; l >>= 1, r >>= 1){",
            "            if(l & 1) ret += tree[y][l++];",
            "            if(r & 1) ret += tree[y][--r];",
            "        }",
            "        return ret;",
            "    }",
            "    T query(int y1, int x1, int y2, int x2){",
            "        T ret = 0;",
            "        for(y1 += sizY, y2 += sizY + 1; y1 < y2; y1 >>= 1, y2 >>= 1){",
            "            if(y1&1) ret += query1D(y1++, x1, x2);",
            "            if(y2&1) ret += query1D(--y2, x1, x2);",
            "        }",
            "        return ret;",
            "    }",
            "    T merge(T, T);",
            "};"
        ],
        "description": "2D Segment Tree"
    },
    "Aho-Corasick": {
        "prefix": [
            "aho",
            "corasick",
            "aho-corasick"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/9250",
            " * Test : Accepted",
            " * Last Updated : 2023.04.02 03:00 AM (KST)",
            " */",
            "struct AhoCorasick {",
            "    struct Trie {",
            "        Trie *nxt[26];",
            "        Trie *fail;",
            "        bool output;",
            "",
            "        Trie() {",
            "            for(int i=0;i<26;++i) nxt[i]=nullptr;",
            "            fail=nullptr;",
            "            output=false;",
            "        }",
            "        ~Trie() {",
            "            for(int i=0;i<26;++i) if(nxt[i]) delete nxt[i];",
            "        }",
            "    } *root;",
            "    AhoCorasick() { root = new Trie(); }",
            "    void insert(const string &S) {",
            "        Trie *cur = root;",
            "        int N = (int)S.size();",
            "        for(int i = 0; i < N; ++i) {",
            "            int nxt = S[i] - 'a';",
            "            if(cur->nxt[nxt] == nullptr) cur->nxt[nxt] = new Trie();",
            "            cur = cur->nxt[nxt];",
            "        }",
            "        cur->output=true;",
            "    }",
            "    void build() {",
            "        queue<Trie*> Q;",
            "        root->fail = root;",
            "        Q.push(root);",
            "        while(!Q.empty()) {",
            "            Trie* cur = Q.front(); Q.pop();",
            "",
            "            for(int i = 0; i < 26; ++i) {",
            "                Trie *next = cur->nxt[i];",
            "                if(next == nullptr) continue;",
            "                if(cur == root) next->fail = root;",
            "                else {",
            "                    Trie *dst = cur->fail;",
            "                    while(dst != root && dst->nxt[i] == nullptr) dst = dst->fail;",
            "                    if(dst->nxt[i]) dst = dst->nxt[i];",
            "                    next->fail = dst;",
            "                }",
            "                if(next->fail->output) next->output = true;",
            "                Q.push(next);",
            "            }",
            "        }",
            "    }",
            "    bool find(const string &S) {",
            "        Trie *cur = root;",
            "        int N = (int)S.size();",
            "        for(int i = 0; i < N; ++i) {",
            "            int nxt = S[i] - 'a';",
            "            while(cur != root && cur->nxt[nxt] == nullptr) cur = cur->fail;",
            "            if(cur->nxt[nxt]) cur = cur->nxt[nxt];",
            "            if(cur->output) return true;",
            "        }",
            "        return false;",
            "    }",
            "};"
        ],
        "description": "Aho-Corasick"
    },
    "Dijkstra": {
        "prefix": [
            "dijkstra"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/1753",
            " * Test : Accepted",
            " * Last Updated : 2023.04.02 09:07 AM (KST)",
            " */",
            "template<typename T> struct Dijkstra {",
            "    const T INF = numeric_limits<T>::max();",
            "    Graph<pair<int, T>> G;",
            "    int N;",
            "    Dijkstra(Graph<pair<int, T>> G):G(G) { N = (int)G.size(); }",
            "    vector<T> dijkstra(int S) {",
            "        vector<T> dist(N + 1, INF);",
            "        priority_queue<pair<T, int>, vector<pair<T, int>>, greater<>> pq;",
            "        pq.emplace(dist[S] = 0, S);",
            "        while(!pq.empty()) {",
            "            auto [d, cur] = pq.top(); pq.pop();",
            "            if(dist[cur] != d) continue;",
            "            for(auto [nxt, w] : G[cur]) {",
            "                if(dist[nxt] > dist[cur] + w) {",
            "                    dist[nxt] = dist[cur] + w;",
            "                    pq.emplace(dist[nxt], nxt);",
            "                }",
            "            }",
            "        }",
            "        return dist;",
            "    }",
            "};"
        ],
        "description": "Dijkstra"
    },
    "Dinic": {
        "prefix": [
            "flow",
            "dinic"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/11377",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 12:52 AM (KST)",
            " */",
            "struct Dinic {",
            "    struct Edge {",
            "        int to, c, f;",
            "        Edge* r;",
            "        Edge() { Edge(-1, 0); }",
            "        Edge(int _to, int _c) :to(_to), c(_c), f(0), r(nullptr) { }",
            "        int spare() { return c - f; }",
            "        void setRev(Edge* rev) { r = rev; }",
            "    };",
            "",
            "    vector<vector<Edge*>> graph;",
            "    vector<int> level, work;",
            "    int src, snk, asrc, asnk;",
            "",
            "    Dinic() { }",
            "    void init(int N) {",
            "        src = N + 1; snk = src + 1; asrc = snk + 1; asnk = asrc + 1;",
            "        N += 5;",
            "        graph.resize(N); level.resize(N); work.resize(N);",
            "    }",
            "    void clear() { graph.clear(); level.clear(); work.clear(); }",
            "",
            "    bool bfs(int s, int e) {",
            "        fill(level.begin(), level.end(), -1);",
            "        level[s] = 0;",
            "",
            "        queue<int> q;",
            "        q.push(s);",
            "",
            "        while (!q.empty()) {",
            "            int t = q.front(); q.pop();",
            "",
            "            for (auto i : graph[t]) {",
            "                if (i->spare() > 0 && level[i->to] == -1) {",
            "                    level[i->to] = level[t] + 1;",
            "                    q.push(i->to);",
            "                }",
            "            }",
            "        }",
            "        return level[e] != -1;",
            "    }",
            "",
            "    int dfs(int s, int e, int f) {",
            "        if (s == e)return f;",
            "",
            "        for (int& i = work[s]; i < (int)graph[s].size(); i++) {",
            "            Edge* now = graph[s][i];",
            "            if (level[now->to] == level[s] + 1 && now->spare() > 0) {",
            "                int ret = dfs(now->to, e, min(f, now->spare()));",
            "                if (ret > 0) {",
            "                    now->f += ret;",
            "                    now->r->f -= ret;",
            "                    return ret;",
            "                }",
            "            }",
            "        }",
            "        return 0;",
            "    }",
            "",
            "    int Flow(int s, int e) {",
            "        int flow = 0;",
            "        while (bfs(s, e)) {",
            "            fill(work.begin(), work.end(), 0);",
            "            while (1) {",
            "                int ret = dfs(s, e, 0x3f3f3f3f);",
            "                if (ret == 0)break;",
            "                flow += ret;",
            "            }",
            "        }",
            "        return flow;",
            "    }",
            "",
            "    Edge* addEdge(int u, int v, int c, bool directed = true, bool Unique = false) {",
            "        if (Unique) {",
            "            for (auto i : graph[u]) {",
            "                if (i->to == v) {",
            "                    i->c += c;",
            "                    if (!directed)return i;",
            "                    break;",
            "                }",
            "            }",
            "            if (!directed) {",
            "                for (auto i : graph[v]) {",
            "                    if (i->to == u) {",
            "                        i->c += c;",
            "                        return i;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "",
            "        Edge* uv = new Edge(v, c);",
            "        Edge* vu = new Edge(u, directed ? 0 : c);",
            "        uv->setRev(vu); vu->setRev(uv);",
            "        graph[u].push_back(uv);",
            "        graph[v].push_back(vu);",
            "",
            "        return uv;",
            "    }",
            "",
            "    Edge* addLREdge(int u, int v, int lower, int upper) {",
            "        if (lower) {",
            "            addEdge(asrc, v, lower);",
            "            addEdge(u, asnk, lower);",
            "        }",
            "",
            "        return addEdge(u, v, upper - lower);",
            "    }",
            "};"
        ],
        "description": "Dinic"
    },
    "Dynamic Segment Tree with Lazy Propagation": {
        "prefix": [
            "dseglazy",
            "dynamic_segment_lazy"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/20212",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 03:04 PM (KST)",
            " */",
            "const int MAXL = 1000000000;",
            "template<typename T>",
            "struct DynamicSegmentLazy{",
            "    struct Node{",
            "        int l, r; // range",
            "        T data, lazy;",
            "        Node *left, *right;",
            "        Node():l(1),r(MAXL),data(0),lazy(0),left(0),right(0) { }",
            "        void extend(T lzy=0){",
            "            if(l == r)return;",
            "            if(left == 0){ //if leaf node",
            "                left  = new Node();",
            "                right =  new Node();",
            "                int m = (l + r) / 2;",
            "                left->l  = l;",
            "                left->r  = m;",
            "                right->l = m + 1;",
            "                right->r = r;",
            "            }",
            "            left->lazy += lzy;",
            "            right->lazy += lzy;",
            "            return;",
            "        }",
            "    };",
            "    Node *tree;",
            "",
            "    DynamicSegmentLazy() { tree = new Node(); }",
            "    void pushdown(Node *cur){",
            "        if(cur->lazy){",
            "            cur->data += (cur->r - cur->l + 1) * cur->lazy;",
            "            cur->extend(cur->lazy);",
            "            cur->lazy = 0;",
            "        }",
            "    }",
            "",
            "    void update(Node *cur, int l, int r, T data){",
            "        pushdown(cur);",
            "        if(cur->l > cur->r || cur->l > r || l > cur->r)return;",
            "        if(l <= cur->l && cur->r <= r){",
            "            cur->data += (cur->r - cur->l + 1) * data;",
            "            if(cur->l != cur->r)cur->extend(data);",
            "            return;",
            "        }",
            "        cur->extend();",
            "        update(cur->left, l, r, data);",
            "        update(cur->right, l, r, data);",
            "        cur->data = mergeNode(cur->left->data, cur->right->data);",
            "    }",
            "    void update(int l, int r, T data){ update(tree, l, r, data); }",
            "",
            "    T query(Node *cur, int l, int r){",
            "        if(cur->l > cur->r || cur->l > r || l > cur->r)return T(0);",
            "        pushdown(cur);",
            "        if(l <= cur->l && cur->r <= r)return cur->data;",
            "        cur->extend();",
            "        return mergeNode(query(cur->left, l, r), query(cur->right, l, r));",
            "    }",
            "    T query(int l, int r){ return query(tree, l, r); }",
            "    T merge(T, T);",
            "};"
        ],
        "description": "Dynamic Segment Tree with Lazy Propagation"
    },
    "Dynamic Segment Tree": {
        "prefix": [
            "dseg",
            "dynamic_segment"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/2042",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 03:00 PM (KST)",
            " */",
            "const int MAXL = 1000000000;",
            "template<typename T>",
            "struct DynamicSegment{",
            "    struct Node{",
            "        int l, r; // range",
            "        T data;",
            "        Node *left, *right;",
            "        Node():l(1),r(MAXL),data(0),left(nullptr),right(nullptr) { }",
            "        void extend(){",
            "            if(l == r)return;",
            "            if(left == nullptr){ //if leaf node",
            "                left  = new Node();",
            "                right =  new Node();",
            "                int mid = (l + r) / 2;",
            "                left->l  = l;",
            "                left->r  = mid;",
            "                right->l = mid + 1;",
            "                right->r = r;",
            "            }",
            "            return;",
            "        }",
            "    };",
            "    Node *tree;",
            "",
            "    DynamicSegment() { tree = new Node(); }",
            "    void update(Node *cur, int x, T data){",
            "        if(x < cur->l || cur->r < x)return;",
            "        if(cur->l == cur->r)return cur->data = data, (void)0;",
            "        cur->extend();",
            "        update(cur->left, x, data);",
            "        update(cur->right, x, data);",
            "        cur->data = mergeNode(cur->left->data, cur->right->data);",
            "    }",
            "    void update(int x, T data){ update(tree, x, data); }",
            "",
            "    T query(Node *cur, int l, int r){",
            "        if(cur->l > cur->r || cur->r < l || cur->l > r)return T(0);",
            "        if(l <= cur->l && cur->r <= r)return cur->data;",
            "        cur->extend();",
            "        return mergeNode(query(cur->left, l, r), query(cur->right, l, r));",
            "    }",
            "    T query(int l, int r){ return query(tree, l, r); }",
            "    T merge(T, T);",
            "};"
        ],
        "description": "Dynamic Segment Tree"
    },
    "Fast Input": {
        "prefix": [
            "fastinput"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/1000",
            " * Test : Accepted",
            " * Last Updated : 2023.04.02 01:22 AM (KST)",
            " */",
            "#define BUFFERMAX 1 << 19",
            "struct IO {",
            "    char buf[BUFFERMAX];",
            "",
            "    char _read() {",
            "        static int idx = BUFFERMAX;",
            "        if(idx == BUFFERMAX){",
            "            fread(buf, 1, BUFFERMAX, stdin);",
            "            idx = 0;",
            "        }",
            "        return buf[idx++];",
            "    }",
            "",
            "    char readChar() {",
            "        char ret = _read();",
            "        while(ret == 10 || ret == 32) ret = _read();",
            "        return ret;",
            "    }",
            "",
            "    string readString() {",
            "        string ret = \"\";",
            "        char now = _read();",
            "        while(now == 10 || now == 32) now = _read();",
            "        while(true) {",
            "            ret += now;",
            "            now = _read();",
            "            if(now == 10 || now == 32) break;",
            "        }",
            "        return ret;",
            "    }",
            "",
            "    template<typename T> T readInt() {",
            "        T ret = 0;",
            "        bool minus = false;",
            "        char now = _read();",
            "        while(now == 10 || now == 32) now = _read();",
            "        if(now == '-') minus = true, now = _read();",
            "        while(48 <= now && now <= 57) {",
            "            ret = ret * 10 + now - 48;",
            "            now = _read();",
            "        }",
            "        if(minus) ret *= -1;",
            "        return ret;",
            "    }",
            "",
            "    void read(int &x) { x = readInt<int>(); }",
            "    void read(long long &x) { x = readInt<long long>(); }",
            "    void read(char &x) { x = readChar(); }",
            "    void read(string &x) { x = readString(); }",
            "    template<typename Type, typename... Types> void read(Type &arg, Types &...args) {  read(arg); read(args...); }",
            "} io;",
            "",
            "template<typename T>",
            "IO& operator>> (IO& in, T &x) { in.read(x); return in; }",
            "",
            "#define cin io",
            "#define istream IO"
        ],
        "description": "Fast Input"
    },
    "Fenwick Tree": {
        "prefix": [
            "fenwick",
            "fenwick_tree"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/2042",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 03:12 PM (KST)",
            " */",
            "template<typename T>",
            "struct Fenwick{",
            "    vector<T> tree, input;",
            "    int siz;",
            "",
            "    Fenwick(){ }",
            "    Fenwick(int N){ setSize(N); }",
            "",
            "    void setSize(int N){",
            "        siz  = N;",
            "        tree = input = vector<T>(siz + 1);",
            "    }",
            "    void putItem(int idx, T data){ input[idx] = data; __update(idx, data); }",
            "    void __update(int idx, T data){",
            "        for(; idx <= siz; idx += (idx & -idx)) tree[idx] += data;",
            "    }",
            "    void update(int idx, T data, bool add=false){",
            "        if(add) __update(idx, data), input[idx] += data;",
            "        else __update(idx, data - input[idx]), input[idx] = data;",
            "    }",
            "    T query(int idx) {",
            "        T ret = 0;",
            "        for(; idx ; idx -= (idx & -idx)) ret += tree[idx];",
            "        return ret;",
            "    }",
            "    T query(int l, int r){ return query(r) - query(l - 1); }",
            "};"
        ],
        "description": "Fenwick Tree"
    },
    "Floyd": {
        "prefix": [
            "floyd"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/11780",
            " * Test : Accepted",
            " * Last Updated : 2023.04.02 03:34 AM (KST)",
            " */",
            "using namespace std;",
            "",
            "template<typename T> struct Floyd {",
            "    const T INF = numeric_limits<T>::max() / 2;",
            "    vector<vector<T>> DP;",
            "    vector<vector<int>> path;",
            "    int N;",
            "    Floyd(int N) : N(N) {",
            "        DP = vector<vector<T>>(N, vector<T>(N, INF));",
            "        path = vector<vector<int>>(N, vector<int>(N, -1));",
            "        for (int i = 0; i < N; ++i) DP[i][i] = 0;",
            "    }",
            "    void addEdge(int u, int v, T w) { DP[u][v] += w; }",
            "    void setEdge(int u, int v, T w) { DP[u][v]  = w; }",
            "    void minEdge(int u, int v, T w) { DP[u][v]  = min(DP[u][v], w); }",
            "    void floyd() {",
            "        for(int k = 0; k < N; ++k) {",
            "            for(int i = 0; i < N; ++i) {",
            "                for(int j = 0; j < N; ++j) {",
            "                    if(DP[i][j] > DP[i][k] + DP[k][j]) {",
            "                        DP[i][j] = DP[i][k] + DP[k][j];",
            "                        path[i][j] = k;",
            "                    }",
            "                }",
            "            }",
            "        }",
            "    }",
            "    vector<int> GetPath(int S, int E) {",
            "        vector<int> ret;",
            "        if(S == E || DP[S][E] == INF)return ret;",
            "        function<void(int,int)> findPath = [&](int s, int e) -> void {",
            "            int pre = path[s][e];",
            "            if(pre == -1) return;",
            "            findPath(s,pre);",
            "            ret.push_back(pre);",
            "            findPath(pre,e);",
            "        };",
            "        ret.push_back(S);",
            "        findPath(S, E);",
            "        ret.push_back(E);",
            "        return ret;",
            "    }",
            "    vector<T>& operator[](const int &idx) { return DP[idx]; }",
            "};"
        ],
        "description": "Floyd"
    },
    "Graph": {
        "prefix": [
            "graph"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/1260",
            " * Test : Accepted",
            " * Last Updated : 2023.04.02 03:20 AM (KST)",
            " */",
            "template<typename T> struct Graph {",
            "    vector<vector<T>> G;",
            "    Graph(int N) { G.resize(N + 1); }",
            "    void addEdge(int u, T data) { G[u].emplace_back(data); }",
            "    int size() { return (int)G.size() - 1; }",
            "    vector<T>& operator[](const int &idx) { return G[idx]; }",
            "};"
        ],
        "description": "Graph"
    },
    "Hashing": {
        "prefix": [
            "hashing"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/21162",
            " * Test : Accepted",
            " * Last Updated : 2023.04.02 02:35 AM (KST)",
            " */",
            "template<long long C, long long HASH_MOD> struct Hashing {",
            "    vector<long long> H, B;",
            "    template<typename T> void build(const T& S) {",
            "        H.resize(S.size() + 1);",
            "        B.resize(S.size() + 1); B[0] = 1;",
            "        for(int i = 1; i <= (int)S.size(); ++i) H[i] = (H[i - 1] * C + S[i - 1]) % HASH_MOD;",
            "        for(int i = 1; i <= (int)S.size(); ++i) B[i] = B[i - 1] * C % HASH_MOD;",
            "    }",
            "    long long get(int s, int e) {",
            "        long long ret = (H[e] - H[s - 1] * B[e - s + 1]) % HASH_MOD;",
            "        if(ret < 0) ret += HASH_MOD;",
            "        return ret;",
            "    }",
            "    void chk_setting() { assert(gcd(C, HASH_MOD) == 1); }",
            "};"
        ],
        "description": "Hashing"
    },
    "Heavy Light Decomposition": {
        "prefix": [
            "hld",
            "heavy_light_decomposition"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/13510",
            " * Test : Accepted",
            " * Last Updated : 2023.04.02 09:15 AM (KST)",
            " */",
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/1260",
            " * Test : Accepted",
            " * Last Updated : 2023.04.02 03:20 AM (KST)",
            " */",
            "template<typename T> struct Graph {",
            "    vector<vector<T>> G;",
            "    Graph(int N) { G.resize(N + 1); }",
            "    void addEdge(int u, T data) { G[u].emplace_back(data); }",
            "    int size() { return (int)G.size() - 1; }",
            "    vector<T>& operator[](const int &idx) { return G[idx]; }",
            "};",
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/2042",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 09:57 PM (KST)",
            " */",
            "template<typename T>",
            "struct Segment {",
            "    vector<T> tree;",
            "    int siz;",
            "",
            "    Segment(int N = 1 << 17) {",
            "        for(siz = 1; siz < N; siz <<= 1);",
            "        tree = vector<T>(siz << 1);",
            "    }",
            "    void update(int idx, T data) {",
            "        tree[idx += siz] = data;",
            "        while(idx >>= 1) tree[idx] = merge(tree[idx << 1], tree[idx << 1 | 1]);",
            "    }",
            "    T query(int l, int r, int s, int e, int pos) {",
            "        if(s <= l && r <= e) return tree[pos];",
            "        if(e <  l || r <  s) return 0;",
            "        int mid = (l + r) / 2;",
            "        return merge(query(l, mid, s, e, pos << 1) , query(mid + 1, r, s, e, pos << 1 | 1));",
            "    }",
            "    T query(int s, int e) { return query(0, siz - 1, s, e, 1); }",
            "    T merge(T, T);",
            "};",
            "",
            "struct HLD {",
            "    Graph<int> G;",
            "    vector<int> par, top, dep, siz, in, out;",
            "    Segment<int> seg;",
            "    int id;",
            "    HLD(Graph<int> G):G(G) {",
            "        int N = (int)G.size();",
            "        siz = par = top = dep = in = out = vector<int>(N);",
            "        seg = Segment<int>(N);",
            "        id = 0;",
            "    }",
            "    void dfs(int cur=1, int prev=0) {",
            "        siz[cur] = 1;",
            "        par[cur] = prev;",
            "        dep[cur] = dep[prev] + 1;",
            "        for(int &nxt : G[cur]) {",
            "            if(nxt == prev) continue;",
            "            dfs(nxt, cur);",
            "            siz[cur] += siz[nxt];",
            "            if(siz[nxt] > siz[G[cur][0]]) swap(nxt, G[cur][0]);",
            "        }",
            "    }",
            "    void dfs2(int cur=1, int prev=0) {",
            "        in[cur] = ++id;",
            "        if(cur == 1) top[cur] = 1;",
            "        for(int nxt: G[cur]) {",
            "            if(nxt == prev)continue;",
            "            top[nxt] = (nxt == G[cur][0] ? top[cur] : nxt);",
            "            dfs2(nxt, cur);",
            "        }",
            "        out[cur] = id;",
            "    }",
            "    void update(int, int);",
            "    int query(int, int);",
            "};"
        ],
        "description": "Heavy Light Decomposition"
    },
    "KMP": {
        "prefix": [
            "kmp"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/1786",
            " * Test : Accepted",
            " * Last Updated : 2023.04.02 03:04 AM (KST)",
            " */",
            "template<typename T> struct KMP {",
            "    vector<int> fail;",
            "    vector<int> failure(const T &Q) {",
            "        fail.resize((int)Q.size() + 1);",
            "        for(int i = 1, j = 0; i < (int)Q.size(); ++i) {",
            "            while(j > 0 && Q[i] != Q[j]) j = fail[j - 1];",
            "            if(Q[i] == Q[j]) fail[i] = ++j;",
            "        }",
            "        return fail;",
            "    }",
            "    vector<int> kmp(const T& P, const T& Q) {",
            "        if(fail.size() == 0) failure(Q);",
            "        vector<int> res;",
            "        for(int i = 0, j = 0; i < (int)P.size(); ++i) {",
            "            while(j > 0 && P[i] != Q[j]) j = fail[j - 1];",
            "            if(P[i] == Q[j]) {",
            "                if(j + 1 == (int)Q.size()) res.push_back(i - (int)Q.size() + 1), j = fail[j];",
            "                else ++j;",
            "            }",
            "        }",
            "        return res;",
            "    }",
            "};"
        ],
        "description": "KMP"
    },
    "NTT": {
        "prefix": [
            "ntt"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/15576",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 12:31 AM (KST)",
            " */",
            "const long long W = 3;",
            "const long long MOD = 998244353;",
            "",
            "void _NTT(vector<long long> &V, bool inv = false) {",
            "    int N = (int)V.size();",
            "    vector<long long> root(N >> 1);",
            "    for(int i = 1, j = 0; i < N; i++) {",
            "        int bit = (N >> 1);",
            "        for(; j >= bit; bit >>= 1) j &= ~bit;",
            "        j |= bit;",
            "        if(i < j) swap(V[i], V[j]);",
            "    }",
            "    long long angle = power(W, (MOD - 1) / N, MOD);",
            "    if(inv) angle = power(angle, MOD - 2, MOD);",
            "    root[0] = 1;",
            "    for(int i = 1; i * 2 < N; i++) root[i] = root[i - 1] * angle % MOD;",
            "    for(int i = 2; i <= N; i <<= 1) {",
            "        long long step = N / i;",
            "        for(int j = 0; j < N; j += i) {",
            "            for(int k = 0; k * 2 < i; k++) {",
            "                long long u = V[j | k];",
            "                long long v = V[j | k | i >> 1] * root[step * k] % MOD;",
            "                V[j | k] = (u + v) % MOD;",
            "                V[j | k | i >> 1] = (u - v) % MOD;",
            "                if(V[j | k | i >> 1] < 0) V[j | k | i >> 1] += MOD;",
            "            }",
            "        }",
            "    }",
            "    if(inv) {",
            "        long long t = power(1LL * N, MOD - 2, MOD);",
            "        for(int i = 0; i < N; i++) V[i] = (V[i] * t) % MOD;",
            "    }",
            "}",
            "",
            "vector<long long> multiply(const vector<long long> &vec1, const vector<long long> &vec2) {",
            "    vector<long long> A(vec1.begin(), vec1.end());",
            "    vector<long long> B(vec2.begin(), vec2.end());",
            "    int L = (int)vec1.size(), R = (int)vec2.size(), N;",
            "    for(N = 2; N < L + R; N <<= 1);",
            "    A.resize(N); B.resize(N);",
            "    _NTT(A); _NTT(B);",
            "    for(int i = 0; i < N; i++) A[i] = A[i] * B[i] % MOD;",
            "    _NTT(A, true);",
            "    return A;",
            "}"
        ],
        "description": "NTT"
    },
    "Palindrome Tree": {
        "prefix": [
            "palindrome_tree",
            "eertree"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/10066",
            " * Test : Accepted",
            " * Last Updated : 2023.04.02 02:55 AM (KST)",
            " */",
            "template<typename T = int> struct PalindromeTree {",
            "    struct Node {",
            "        int len, suffix_link;",
            "        T cnt;",
            "        map<char, int> nxt;",
            "",
            "        Node() : Node(0, 0) { }",
            "        Node(int _len, int _link) {",
            "            len = _len; suffix_link = _link;",
            "            cnt = T();",
            "        }",
            "    };",
            "",
            "    vector<Node> tree;",
            "    int cnt, last_suffix;",
            "",
            "    PalindromeTree(int N) {",
            "        tree.resize(N);",
            "        cnt = last_suffix = 2;",
            "        tree[1] = Node(-1, 1);",
            "        tree[2] = Node(0, 1);",
            "    }",
            "    void init(const string &S) {",
            "        auto chk = [&](int idx, int cur) {",
            "            return idx - tree[cur].len - 1 >= 0 && S[idx - tree[cur].len - 1] == S[idx];",
            "        };",
            "        for(int i = 0; i < (int)S.size(); ++i) {",
            "            int cur = last_suffix;",
            "            while(!chk(i, cur)) cur = tree[cur].suffix_link;",
            "            if(tree[cur].nxt.count(S[i])) {",
            "                last_suffix = tree[cur].nxt[S[i]];",
            "                ++ tree[last_suffix].cnt;",
            "                continue;",
            "            }",
            "            last_suffix = tree[cur].nxt[S[i]] = ++cnt;",
            "            int nxt = cnt;",
            "            tree[nxt].len = tree[cur].len + 2;",
            "            ++ tree[nxt].cnt;",
            "            if(tree[nxt].len == 1) {",
            "                tree[nxt].suffix_link = 2;",
            "                continue;",
            "            }",
            "            while(cur > 1) {",
            "                cur = tree[cur].suffix_link;",
            "                if(chk(i, cur)) {",
            "                    tree[nxt].suffix_link = tree[cur].nxt[S[i]];",
            "                    break;",
            "                }",
            "            }",
            "        }",
            "    }",
            "    Node& operator[](const int &idx) { return tree[idx]; }",
            "};"
        ],
        "description": "Palindrome Tree"
    },
    "Persistent Segment Tree": {
        "prefix": [
            "persistent_segment_tree",
            "pst"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/7469",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 03:21 PM (KST)",
            " */",
            "template<typename T>",
            "struct PST{",
            "    struct Node{",
            "        Node *left, *right;",
            "        T data;",
            "        Node(Node *l = nullptr, Node *r = nullptr, T v=0):left(l), right(r), data(v) { }",
            "        Node *push(int l, int r, int x, T _data) {",
            "            if(r < x || x < l) return this;",
            "            if(l == r) return new Node(0, 0, this->data + _data);",
            "            int mid = l + (r - l) / 2;",
            "            Node *L = left->push(l, mid, x, _data);",
            "            Node *R = right->push(mid + 1, r, x, _data);",
            "            return new Node(L, R, L->data + R->data);",
            "        }",
            "    };",
            "    Node *roots[100002];",
            "    int siz;",
            "",
            "    PST() { setting(); }",
            "    PST(int N) { setting(N); }",
            "    void setting(int N = 2e9 + 10){",
            "        siz = N;",
            "        roots[0] = new Node();",
            "        roots[0]->left = roots[0]->right = roots[0];",
            "    }",
            "",
            "    void expand(int p){ roots[p] = roots[p - 1]; }",
            "    void update(int p, int idx, T data, bool _expand=false){",
            "        if(_expand) expand(p);",
            "        roots[p] = roots[p]->push(1, siz, idx, data);",
            "    }",
            "",
            "    T query(Node *cur, int l, int r, int s, int e){",
            "        if(s <= l && r <= e)return cur->data;",
            "        if(e <  l || r <  s)return 0;",
            "        int mid = l + (r - l) / 2;",
            "        return query(cur->left, l, mid, s, e) + query(cur->right, mid + 1, r, s, e);",
            "    }",
            "    T query(int s, int e, int p){ return query(roots[p], 1, siz, s, e); }",
            "",
            "    T kth(Node *s, Node *e, int l, int r, int k){",
            "        if(l == r)return l;",
            "        int mid = l + (r - l) / 2;",
            "        T data = e->left->data - s->left->data;",
            "        if(data >= k)return kth(s->left, e->left, l, mid, k);",
            "        return kth(s->right, e->right, mid + 1, r, k - data);",
            "    }",
            "    T kth(int s, int e, int k){ return kth(roots[s], roots[e], 1, siz, k); }",
            "};"
        ],
        "description": "Persistent Segment Tree"
    },
    "Power": {
        "prefix": [
            "power"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/1629",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 10:44 PM (KST)",
            " */",
            "template<typename T, typename modulo>",
            "T power(T a, T b, modulo mod) {",
            "    T ret = 1;",
            "    while(b) {",
            "        if(b & 1) ret = ret * a % mod;",
            "        a = a * a % mod;",
            "        b >>= 1;",
            "    }",
            "    return ret;",
            "}"
        ],
        "description": "Power"
    },
    "Range Fenwick Tree": {
        "prefix": [
            "range_fenwick_tree",
            "rfenwick"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/10999",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 03:19 PM (KST)",
            " */",
            "template<typename T>",
            "struct FenwickRU{ // Fenwick Range Update",
            "    vector<T> tree, add, mul, input;",
            "    int siz;",
            "",
            "    FenwickRU(){ }",
            "    FenwickRU(int N) { setSize(N); }",
            "    void setSize(int N) {",
            "        siz = N;",
            "        tree = add = mul = input = vector<T>(N + 1);",
            "    }",
            "    void putItem(int idx, T data) { update(idx, idx, data), input[idx] = data; }",
            "    void __update(int idx, T _mul, T _add){",
            "        for(; idx <= siz; idx += idx & -idx){",
            "            add[idx] += _add;",
            "            mul[idx] += _mul;",
            "        }",
            "    }",
            "    void update(int l, int r, T data){",
            "        __update(l, data, (l - 1) * -data);",
            "        __update(r + 1, -data, data * r);",
            "    }",
            "    T query(int idx){",
            "        T __add = 0, __mul = 0;",
            "        for(int i = idx; i; i -= i & -i) {",
            "            __add += add[i];",
            "            __mul += mul[i];",
            "        }",
            "        return __mul * idx + __add;",
            "    }",
            "    T query(int l, int r){ return query(r) - query(l - 1); }",
            "};"
        ],
        "description": "Range Fenwick Tree"
    },
    "SCC": {
        "prefix": [
            "scc"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/2150",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 12:35 AM (KST)",
            " */",
            "struct SCC{",
            "    bool _set_size;",
            "    stack<int> st;",
            "    vector<vector<int>> adj, scc;",
            "    vector<int> d, used;",
            "    int id, N;",
            "",
            "    SCC():_set_size(false) {}",
            "    SCC(int _N){",
            "        _set_size = true;",
            "        setSize(_N);",
            "    }",
            "    void setSize(int _N) {",
            "        _set_size = true;",
            "        N = _N;",
            "        id = 0;",
            "        adj = vector<vector<int>>(N + 1);",
            "        d = used = vector<int>(N + 1);",
            "    }",
            "",
            "    void addEdge(int a, int b, bool bidirected = false) {",
            "        adj[a].push_back(b);",
            "        if(bidirected) adj[b].push_back(a);",
            "    }",
            "",
            "    int dfs(int x){",
            "        d[x] = ++id;",
            "",
            "        st.push(x);",
            "        int par = d[x];",
            "        for(const auto &i : adj[x]){",
            "            if(!d[i])par = min(par, dfs(i));",
            "            else if(!used[i])par = min(par, d[i]);",
            "        }",
            "",
            "        if(par == d[x]){",
            "            vector<int> now;",
            "            while(!st.empty()){",
            "                int t = st.top();st.pop();",
            "                used[t] = true;",
            "                now.push_back(t);",
            "                if(t == x)break;",
            "            }",
            "            scc.push_back(now);",
            "        }",
            "        return par;",
            "    }",
            "",
            "    void run(){ for(int i=1;i<=N;i++)if(!d[i])dfs(i); }",
            "    int getSize() { return (int)scc.size(); }",
            "};"
        ],
        "description": "SCC"
    },
    "Segment Tree with Lazy Propagation": {
        "prefix": [
            "seglazy",
            "segmentlazy"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/10999",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 09:56 PM (KST)",
            " */",
            "template<typename T>",
            "struct SegmentLazy {",
            "    vector<T> tree, lazy;",
            "    int siz;",
            "",
            "    SegmentLazy(int N = 1 << 17) {",
            "        for(siz = 1; siz < N; siz <<= 1);",
            "        lazy = tree = vector<T>(siz << 1);",
            "    }",
            "    void putItem(int idx, T data) { tree[idx + siz] = data; }",
            "    void build() {",
            "        for(int i = siz - 1; i; --i) tree[i] = merge(tree[i << 1], tree[i << 1 | 1]);",
            "    }",
            "    void propagate(int l, int r, int pos) {",
            "        if(!lazy[pos]) return;",
            "        if(l != r) {",
            "            lazy[pos << 1] = merge(lazy[pos << 1], lazy[pos]);",
            "            lazy[pos << 1 | 1] = merge(lazy[pos << 1 | 1], lazy[pos]);",
            "        }",
            "        tree[pos] += lazy[pos] * (r - l + 1);",
            "        lazy[pos] = 0;",
            "    }",
            "    void update(int l, int r, int s, int e, int pos, T data) {",
            "        if(s <= l && r <= e) {",
            "            lazy[pos] += data;",
            "            propagate(l, r, pos);",
            "            return;",
            "        }",
            "        propagate(l, r, pos);",
            "        if(e <  l || r <  s) return;",
            "        int mid = (l + r) / 2;",
            "        update(l, mid, s, e, pos << 1, data);",
            "        update(mid + 1, r, s, e, pos << 1 | 1, data);",
            "        tree[pos] = merge(tree[pos << 1], tree[pos << 1 | 1]);",
            "    }",
            "    void update(int s, int e, T data) { update(0, siz - 1, s, e, 1, data); }",
            "    T query(int l, int r, int s, int e, int pos) {",
            "        propagate(l, r, pos);",
            "        if(s <= l && r <= e) return tree[pos];",
            "        if(e <  l || r <  s) return 0;",
            "        int mid = (l + r) / 2;",
            "        return merge(query(l, mid, s, e, pos << 1), query(mid + 1, r, s, e, pos << 1 | 1));",
            "    }",
            "    T query(int s, int e) { return query(0, siz - 1, s, e, 1); }",
            "    T merge(T, T);",
            "};"
        ],
        "description": "Segment Tree with Lazy Propagation"
    },
    "Segment Tree": {
        "prefix": [
            "segment",
            "segtree"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/2042",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 09:57 PM (KST)",
            " */",
            "template<typename T>",
            "struct Segment {",
            "    vector<T> tree;",
            "    int siz;",
            "",
            "    Segment(int N = 1 << 17) {",
            "        for(siz = 1; siz < N; siz <<= 1);",
            "        tree = vector<T>(siz << 1);",
            "    }",
            "    void update(int idx, T data) {",
            "        tree[idx += siz] = data;",
            "        while(idx >>= 1) tree[idx] = merge(tree[idx << 1], tree[idx << 1 | 1]);",
            "    }",
            "    T query(int l, int r, int s, int e, int pos) {",
            "        if(s <= l && r <= e) return tree[pos];",
            "        if(e <  l || r <  s) return 0;",
            "        int mid = (l + r) / 2;",
            "        return merge(query(l, mid, s, e, pos << 1) , query(mid + 1, r, s, e, pos << 1 | 1));",
            "    }",
            "    T query(int s, int e) { return query(0, siz - 1, s, e, 1); }",
            "    T merge(T, T);",
            "};"
        ],
        "description": "Segment Tree"
    },
    "Splay Tree": {
        "prefix": [
            "splay"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/3444",
            " * Test : Accepted",
            " * Last Updated : 2023.10.29 09:12 PM (KST)",
            " */",
            "template<typename T, const int node_siz = 500000>",
            "struct SplayTree {",
            "    struct Data {",
            "        int sz;",
            "        T mn, mx, sum, value;",
            "        bool flip, dummy;",
            "",
            "        Data(T _value = 0) : value(_value) {",
            "            init();",
            "            flip = dummy = false;",
            "        }",
            "",
            "        void init() {",
            "            sz = 1;",
            "            mn = mx = sum = value;",
            "        }",
            "    };",
            "",
            "    struct Node {",
            "        Node *l, *r, *p;",
            "        Data data;",
            "",
            "        Node():Node(0){}",
            "        Node(T _value) : Node(_value, nullptr) {}",
            "",
            "        Node(T _value, Node *_p) {",
            "            p = _p;",
            "            l = r = nullptr;",
            "            data = Data(_value);",
            "        }",
            "",
            "        bool is_left() { return this == p->l; }",
            "",
            "        bool is_right() { return this == p->r; }",
            "",
            "        bool is_root() { return p == nullptr || (!is_left() && !is_right()); }",
            "",
            "        void merge(Data o) {",
            "            data.sz += o.sz;",
            "            data.mn = min(data.mn, o.mn);",
            "            data.mx = max(data.mx, o.mx);",
            "            data.sum += o.sum;",
            "        }",
            "",
            "        void update() {",
            "            data.init();",
            "            if (l) merge(l->data);",
            "            if (r) merge(r->data);",
            "        }",
            "",
            "        void push() {",
            "            if (data.flip == false) return;",
            "            swap(l, r);",
            "            data.flip = false;",
            "            if (l) l->data.flip ^= 1;",
            "            if (r) r->data.flip ^= 1;",
            "        }",
            "    };",
            "",
            "    Node *root;",
            "    Node *node[node_siz];",
            "",
            "    SplayTree() {}",
            "",
            "    SplayTree(int N, const vector<T> &V) { init(N, V); }",
            "",
            "    void init(int N, const vector<T> &V) {",
            "        const T INF = numeric_limits<T>::max() / 2;",
            "        Node *cur = root = new Node(-INF);",
            "        for (int i = 1; i <= N; ++i) {",
            "            node[V[i]] = cur->r = new Node(V[i], cur);",
            "            cur = cur->r;",
            "        }",
            "        node[N + 1] = cur->r = new Node(INF, cur);",
            "        root->data.dummy = cur->r->data.dummy = true;",
            "        for (int i = N + 1; i >= 1; --i) node[i]->update();",
            "    }",
            "",
            "    void rotate(Node *cur) {",
            "        if (cur->p == nullptr) return;",
            "        Node *p = cur->p;",
            "        p->push();",
            "        cur->push();",
            "",
            "        if (cur->is_left()) {",
            "            if (cur->r) cur->r->p = p;",
            "            p->l = cur->r;",
            "            cur->r = p;",
            "        }",
            "        else {",
            "            if (cur->l) cur->l->p = p;",
            "            p->r = cur->l;",
            "            cur->l = p;",
            "        }",
            "",
            "        if (!p->is_root()) {",
            "            if (p->is_left()) p->p->l = cur;",
            "            else p->p->r = cur;",
            "        }",
            "        else root = cur;",
            "",
            "        cur->p = p->p;",
            "        p->p = cur;",
            "",
            "        p->update();",
            "        cur->update();",
            "    }",
            "",
            "    Node *splay(Node *cur, Node *g = nullptr) {",
            "        while (!cur->is_root() && cur->p != g) {",
            "            if (cur->p->is_root() || cur->p->p == g) {",
            "                rotate(cur);",
            "                continue;",
            "            }",
            "            if (cur->p->p != g) rotate((cur->is_left() ^ cur->p->is_left()) ? cur : cur->p);",
            "            rotate(cur);",
            "        }",
            "        if (g == nullptr) root = cur;",
            "        return root;",
            "    }",
            "",
            "    Node *kth(int k) {",
            "        Node *cur = root;",
            "        cur->push();",
            "        while (true) {",
            "            while (cur->l && cur->l->data.sz > k) {",
            "                cur = cur->l;",
            "                cur->push();",
            "            }",
            "            if (cur->l) k -= cur->l->data.sz;",
            "            if (!k--) break;",
            "            cur = cur->r;",
            "            cur->push();",
            "        }",
            "        return splay(cur);",
            "    }",
            "",
            "    Node *gather(int l, int r) {",
            "        Node *Left = kth(r + 1);",
            "        Node *Right = kth(l - 1);",
            "        return splay(Left, Right)->r->l;",
            "    }",
            "",
            "    Node *flip(int l, int r) {",
            "        Node *cur = gather(l, r);",
            "        cur->data.flip ^= 1;",
            "        return cur;",
            "    }",
            "",
            "    Node *shift(int l, int r, int x) {",
            "        Node *cur = gather(l, r);",
            "        if (x >= 0) {",
            "            x %= (r - l + 1);",
            "            if (x == 0) return cur;",
            "            flip(l, r);",
            "            flip(l, l + x - 1);",
            "            flip(l + x, r);",
            "        }",
            "        else {",
            "            x *= -1;",
            "            x %= (r - l + 1);",
            "            flip(l, r);",
            "            flip(l, r - x);",
            "            flip(r - x + 1, r);",
            "        }",
            "        return gather(l, r);",
            "    }",
            "",
            "    int operator[](const int k) {",
            "        return splay(node[k])->l->data.sz;",
            "    }",
            "",
            "    // Debuging",
            "    void inorder(Node *cur) {",
            "        if(cur == nullptr) return;",
            "        cur->push();",
            "        inorder(cur->l);",
            "        if (cur->data.dummy == false) cout << cur->data << ' ';",
            "        inorder(cur->r);",
            "    }",
            "",
            "    void inorder() { inorder(root); }",
            "};"
        ],
        "description": "Splay Tree"
    },
    "Suffix Array": {
        "prefix": [
            "sa",
            "suffix_array"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/9248",
            " * Test : Accepted",
            " * Last Updated : 2023.04.02 01:54 AM (KST)",
            " */",
            "template<typename T> struct SuffixArray {",
            "    vector<int> pos, sa, lcp;",
            "    int N;",
            "    SuffixArray(const T& S) {",
            "        N = (int)S.size();",
            "        lcp = pos = sa = vector<int>(N);",
            "        vector<int> tmp(N);",
            "        for(int i = 0; i < N; ++i) sa[i] = i, pos[i] = S[i];",
            "        for(int d = 1; ; d <<= 1) {",
            "            function<bool(int, int)> compare = [&](int a, int b) -> bool {",
            "                if(pos[a] != pos[b]) return pos[a] < pos[b];",
            "                if(a + d < N && b + d < N) return pos[a + d] < pos[b + d];",
            "                return a > b;",
            "            };",
            "            sort(sa.begin(), sa.end(), compare);",
            "            for(int i = 1; i < N; ++i) tmp[i] = tmp[i - 1] + compare(sa[i - 1], sa[i]);",
            "            for(int i = 0; i < N; ++i) pos[sa[i]] = tmp[i];",
            "            if(tmp.back() + 1 == N) break;",
            "        }",
            "        // part of LCP",
            "        for(int i = 0, k = 0; i < N; ++i, k = max(k - 1, 0)) {",
            "            if(!pos[i]) continue;",
            "            while(sa[pos[i] - 1] + k < N && sa[pos[i]] + k < N && S[sa[pos[i] - 1] + k] == S[sa[pos[i]] + k]) ++k;",
            "            lcp[pos[i]] = k;",
            "        }",
            "    }",
            "    vector<int> &get_sa() { return sa; }",
            "    vector<int> &get_lcp() { return lcp; }",
            "};"
        ],
        "description": "Suffix Array"
    },
    "Trie": {
        "prefix": [
            "trie"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/5052",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 10:40 PM (KST)",
            " */",
            "namespace Trie{",
            "    struct Node{",
            "        char data;",
            "        map<char, Node*> _next;",
            "        Node() { }",
            "        ~Node() { for(auto &i: _next) delete i.second; }",
            "        Node* insert(char x){ if(!find(x)) _next[x] = new Node(); return _next[x]; }",
            "        Node* next(char x){ return _next.count(x) ? _next[x] : nullptr; }",
            "",
            "        bool find(char x){ return _next.count(x) != 0; }",
            "        bool end(){ return _next.count(0); }",
            "    } *root = new Node();",
            "    int words = 0;",
            "",
            "    bool insert(const string &word){",
            "        bool prefix_exist = false;",
            "        Node *cursor = root;",
            "        for (int i = 0; i < (int)word.size(); i++) {",
            "            cursor = cursor->insert(word[i]);",
            "            if(cursor->end()) prefix_exist = true;",
            "        }",
            "        if(!cursor->end()) {",
            "            cursor->insert(0);",
            "            ++words;",
            "            if(cursor->_next.size() > 1) prefix_exist = true;",
            "        }",
            "        return prefix_exist;",
            "    }",
            "",
            "    bool find(const string &str) {",
            "        Node *cursor = root;",
            "        for (int i = 0; i < (int)str.size(); i++) {",
            "            if(!cursor->find(str[i])) return false;",
            "            cursor = cursor->next(str[i]);",
            "        }",
            "        return cursor->end();",
            "    }",
            "",
            "    void clear() {",
            "        delete root;",
            "        root = new Node();",
            "        words = 0;",
            "    }",
            "}"
        ],
        "description": "Trie"
    },
    "Union Find": {
        "prefix": [
            "unionfind",
            "uf"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/1717",
            " * Test : Accepted",
            " * Last Updated : 2023.04.01 10:47 PM (KST)",
            " */",
            "struct UnionFind {",
            "    vector<int> uf, siz;",
            "    UnionFind(int N) {",
            "        uf.resize(N, -1);",
            "        siz.resize(N, 1);",
            "    }",
            "    int find(int x) { return uf[x] < 0 ? x : uf[x] = find(uf[x]); }",
            "    bool same(int a, int b) { return find(a) == find(b); }",
            "    bool merge(int a, int b) {",
            "        a = find(a); b = find(b);",
            "        if(a == b) return false;",
            "        uf[b] = a;",
            "        siz[a] += siz[b];",
            "        return true;",
            "    }",
            "};"
        ],
        "description": "Union Find"
    },
    "TestCase Main": {
        "prefix": [
            "tcmain"
        ],
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "typedef bool i1;",
            "typedef char i8;",
            "typedef short i16;",
            "typedef int i32;",
            "typedef long long i64;",
            "",
            "typedef unsigned char u8;",
            "typedef unsigned short u16;",
            "typedef unsigned int u32;",
            "typedef unsigned long long u64;",
            "",
            "typedef float f4;",
            "typedef double f8;",
            "typedef long double f16;",
            "",
            "template<typename T> using Vec = vector<T>;",
            "",
            "template<int fp=0> struct fastio { fastio() { ios::sync_with_stdio(false); cin.tie(0); if(fp)cout<<fixed<<' '<<setprecision(fp); } };",
            "",
            "template<typename First, typename Second> inline istream& operator>>(istream &in, pair<First, Second> &_data) { in>>_data.first>>_data.second; return in; }",
            "template<typename First, typename Second> inline ostream& operator<<(ostream &out, pair<First, Second> &_data) { out<<_data.first<<' '<<_data.second; return out; }",
            "template<typename First, typename Second, typename Third> inline istream& operator>>(istream &in, tuple<First, Second, Third> &_data) { in>>get<0>(_data)>>get<1>(_data)>>get<2>(_data); return in; }",
            "template<typename First, typename Second, typename Third> inline ostream& operator<<(ostream &out, tuple<First, Second, Third> &_data) { out<<get<0>(_data)<<' '<<get<1>(_data)<<' '<<get<2>(_data); return out; }",
            "",
            "template<typename T> auto Vector(const int N, const T& value) { return vector(N, value); }",
            "template<typename...Ts> auto Vector(const int N, Ts... args) { return vector(n, Vector(args...))}",
            "template<typename InputType> void in(InputType& x) { cin>>x; }",
            "template<typename InputType, typename... InputTypes> void in(InputType& x, InputTypes& ...y) { cin>>x; in(y...); }",
            "template<typename IterableInputType> void vin(IterableInputType &V, int skip=0) { for(auto &x: V) if(--skip < 0) cin >> x; }",
            "",
            "template<const int p=0, typename OutputType> void out(OutputType x) { cout<<x<<' '; }",
            "template<const int p=0, typename OutputType, typename... OutputTypes> void out(OutputType x, OutputTypes ...y) { cout<<fixed<<setprecision(p)<<x<<' '; out<p>(y...); }",
            "template<const int p=0, typename IterableOutputType> void vout(const IterableOutputType &V, int skip=0) { for(auto &x: V) if(--skip<0) out<p>(x); }",
            "",
            "template<i64 modulo=numeric_limits<i64>::max(), typename... T> i64 Sum(T... x) { return (... + x) % modulo; }",
            "template<i64 modulo=numeric_limits<i64>::max(), typename... T> i64 Mul(T... x) { return (... * x) % modulo; }",
            "",
            "constexpr int dy[] = {-1,1,0,0,-1,-1,1,1,-2,-1,1,2,2,1,-1,-2};",
            "constexpr int dx[] = {0,0,-1,1,-1,1,-1,1,1,2,2,1,-1,-2,-2,-1};",
            "",
            "int main() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(0);",
            "",
            "    int testcase = ${1}; ${2} cin >> testcase;",
            "    while(~--testcase) {",
            "        ${3}",
            "    }",
            "}"
        ],
        "description": "TestCase Main"
    },
    "Main": {
        "prefix": [
            "main"
        ],
        "body": [
            "#include<bits/stdc++.h>",
            "",
            "using namespace std;",
            "",
            "typedef bool i1;",
            "typedef char i8;",
            "typedef short i16;",
            "typedef int i32;",
            "typedef long long i64;",
            "",
            "typedef unsigned char u8;",
            "typedef unsigned short u16;",
            "typedef unsigned int u32;",
            "typedef unsigned long long u64;",
            "",
            "typedef float f4;",
            "typedef double f8;",
            "typedef long double f16;",
            "",
            "template<typename T> using Vec = vector<T>;",
            "",
            "template<int fp=0> struct fastio { fastio() { ios::sync_with_stdio(false); cin.tie(0); if(fp)cout<<fixed<<' '<<setprecision(fp); } };",
            "",
            "template<typename First, typename Second> inline istream& operator>>(istream &in, pair<First, Second> &_data) { in>>_data.first>>_data.second; return in; }",
            "template<typename First, typename Second> inline ostream& operator<<(ostream &out, pair<First, Second> &_data) { out<<_data.first<<' '<<_data.second; return out; }",
            "template<typename First, typename Second, typename Third> inline istream& operator>>(istream &in, tuple<First, Second, Third> &_data) { in>>get<0>(_data)>>get<1>(_data)>>get<2>(_data); return in; }",
            "template<typename First, typename Second, typename Third> inline ostream& operator<<(ostream &out, tuple<First, Second, Third> &_data) { out<<get<0>(_data)<<' '<<get<1>(_data)<<' '<<get<2>(_data); return out; }",
            "",
            "template<typename T> auto Vector(const int N, const T& value) { return vector(N, value); }",
            "template<typename...Ts> auto Vector(const int N, Ts... args) { return vector(n, Vector(args...))}",
            "template<typename InputType> void in(InputType& x) { cin>>x; }",
            "template<typename InputType, typename... InputTypes> void in(InputType& x, InputTypes& ...y) { cin>>x; in(y...); }",
            "template<typename IterableInputType> void vin(IterableInputType &V, int skip=0) { for(auto &x: V) if(--skip < 0) cin >> x; }",
            "",
            "template<const int p=0, typename OutputType> void out(OutputType x) { cout<<x<<' '; }",
            "template<const int p=0, typename OutputType, typename... OutputTypes> void out(OutputType x, OutputTypes ...y) { cout<<fixed<<setprecision(p)<<x<<' '; out<p>(y...); }",
            "template<const int p=0, typename IterableOutputType> void vout(const IterableOutputType &V, int skip=0) { for(auto &x: V) if(--skip<0) out<p>(x); }",
            "",
            "template<i64 modulo=numeric_limits<i64>::max(), typename... T> i64 Sum(T... x) { return (... + x) % modulo; }",
            "template<i64 modulo=numeric_limits<i64>::max(), typename... T> i64 Mul(T... x) { return (... * x) % modulo; }",
            "",
            "constexpr int dy[] = {-1,1,0,0,-1,-1,1,1,-2,-1,1,2,2,1,-1,-2};",
            "constexpr int dx[] = {0,0,-1,1,-1,1,-1,1,1,2,2,1,-1,-2,-2,-1};",
            "",
            "int main() {",
            "    ios::sync_with_stdio(false);",
            "    cin.tie(0);",
            "",
            "    ${1}",
            "}"
        ],
        "description": "Main"
    },
    "BFS": {
        "prefix": [
            "bfs"
        ],
        "body": [
            "/*",
            " * Problem for Testing Template : https://www.acmicpc.net/problem/1260",
            " * Test : Accepted",
            " * Last Updated : 2023.04.02 03:20 AM (KST)",
            " */",
            "template<typename T> struct Graph {",
            "    vector<vector<T>> G;",
            "    Graph(int N) { G.resize(N + 1); }",
            "    void addEdge(int u, T data) { G[u].emplace_back(data); }",
            "    int size() { return (int)G.size() - 1; }",
            "    vector<T>& operator[](const int &idx) { return G[idx]; }",
            "};",
            "",
            "struct BFS {",
            "    Graph<int> G;",
            "    BFS(const Graph<int> _G):G(_G) { }",
            "    vector<int> operator()(int S) {",
            "        vector<int> D(G.size(), -1);",
            "        queue<int> Q({S});",
            "        D[S] = 0;",
            "        while(!Q.empty()) {",
            "            int cur = Q.front(); Q.pop();",
            "            for(int nxt: G[cur]) {",
            "                if(D[nxt] != -1) continue;",
            "                D[nxt] = D[cur] + 1;",
            "                Q.emplace(nxt);",
            "            }",
            "        }",
            "        return D;",
            "    }",
            "};"
        ],
        "description": "BFS"
    },
    "Sort All": {
        "prefix": [
            "sortall",
            "sall"
        ],
        "body": [
            "sort($1.begin(), $1.end());"
        ],
        "description": "Sort All"
    },
    "Compress": {
        "prefix": [
            "Compress"
        ],
        "body": [
            "sort($1.begin(), $1.end());",
            "$1.erase(unique($1.begin(), $1.end()), $1.end());"
        ],
        "description": "Compress"
    }
}